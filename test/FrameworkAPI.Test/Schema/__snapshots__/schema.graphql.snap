schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"Generic interface for capability test specifications."
interface CapabilityTestSpecification {
  "Unique identifier of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestSpecificationId: String!
  "Type of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestType: CapabilityTestType!
  "Date of the creation of the capability test specification.\n[Source: CapabilityTestSpecification]"
  createdAt: DateTime!
  "Description of the capability test specification.\n[Source: CapabilityTestSpecification]"
  description: String
  "Version of the capability test specification.\n[Source: CapabilityTestSpecification]"
  version: Int!
}

interface Error {
  message: String!
}

"Generic interface for machine entities of all machine families."
interface Machine {
  "Number of all alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  activeMachineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String): Long
  "All alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  activeMachineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 10): [MachineAlarm!]
  "The currently active machine alarm that was started first after the current problem occurred.\nIs null, if no alarm is active on the machine.\n[Source: AlarmDataHandler]"
  activePrimalMachineAlarm: MachineAlarm
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartment!
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeatures!
  "Status of licenses for RUBY extensions and connection modules.\n[Source: LicenseManager]"
  licenses: RubyLicenses
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamily!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: String!
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: String!
  "The job entity that is currently produced on the machine if no timestamp is provided.\nOtherwise the job entity that was active at the given timestamp."
  producedJob: ProducedJob
  "The current production status of the machine.\n[Source: MachineSnapshot]"
  productionStatus: ProductionStatus!
  "Query timestamp is not provided:\nMachines OPC-UA server time and latest snapshot time are compared and the latest one is being returned.\n            \nQuery timestamp is provided:\nQuery timestamp is being returned.\n            \n[Source: Machines OPC-UA server time, latest snapshot or query timestamp]"
  time: DateTime
}

"Generic interface for machine time span entities of all machine families."
interface MachineTimeSpan {
  "The start timestamp of the query.\n[Source: Query]"
  from: DateTime!
  "Number of alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  machineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String "If set, only the alarms are counted that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false): Long
  "Alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  machineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "If set, only the alarms are returned that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 100): [MachineAlarm!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Returns all shifts during the query time span.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: Settings + ProductionPeriods (for operators)]"
  shifts: [MachineShift!]
  "The end timestamp of the query.\n[Source: Query]"
  to: DateTime!
}

"Generic interface for produced job entities of all machine families."
interface MaterialLot {
  "End timestamp of production in UTC (machine time) | This is 'null' if the roll is currently produced.\n[Source: MaterialDataHandler]"
  endTime: DateTime
  "ID of the job for which this lot was\/is produced\n[Source: MachineSnapshots]"
  jobId: String!
  "The machine this material lot was produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: MaterialDataHandler]"
  machineId: String!
  "Unique identifier of the material lot\n(All material lots produced on WuH machines are identified by a UID:\nThe UID contains 5 characters indicating the manufacturer,\n6 digits for the commissioning number, UTC time in the format \"yyyymmddhhmmss\"\nand 2 digits for roll number in roll set).\n[Source: MaterialDataHandler]"
  materialLotId: String!
  "Quantity of product contained within the material lot (e.g. length of the roll).\n[Source: MaterialDataHandler]"
  quantity(machineId: String!): NumericValue!
  "Start timestamp of production in UTC (machine time).\n[Source: MaterialDataHandler]"
  startTime: DateTime!
}

"Generic interface for physical assets."
interface PhysicalAsset {
  "Date of the creation of the physical asset.\n[Source: PhysicalAsset]"
  createdAt: DateTime!
  "The defects of the physical asset.\n[Source: PhysicalAsset]"
  defects: [PhysicalAssetDefect!]
  "Date of the delivery of the physical asset.\n[Source: PhysicalAsset]"
  deliveredAt: DateTime
  "Description of the physical asset.\n[Source: PhysicalAsset]"
  description: String
  "Equipment the physical asset is currently equipped by e.g. machine.\n[Source: PhysicalAsset]"
  equippedBy: Equipment
  "The history of the physical asset.\n[Source: PhysicalAsset]"
  history: [PhysicalAssetHistoryItem!]
  "Initial time usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialTimeUsageCounter: Long
  "Initial usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialUsageCounter: Long
  "Date of the last change to the metadata, tests or operations of the physical asset.\n[Source: PhysicalAsset]"
  lastChange: DateTime!
  "Last type of cleaning when the physical asset was last cleaned.\n[Source: PhysicalAsset]"
  lastCleaning: TrackedValueOfCleaningOperationType
  "Last consumed material when the physical asset was last used e.g. color.\n[Source: PhysicalAsset]"
  lastConsumedMaterial: TrackedValueOfString
  "Manufacturer of the physical asset.\n[Source: PhysicalAsset]"
  manufacturer: String
  "Unique identifier of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetId: String!
  "Type of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetType: PhysicalAssetType!
  "Preferred usage location (like: \"EQ12345\" or \"MIRAFLEX AM Dualport\") of the physical asset.\n[Source: PhysicalAsset]"
  preferredUsageLocation: String
  "List of unique scan codes (e.g. QR codes) identifying the physical asset.\n[Source: PhysicalAsset]"
  scanCodes: [String!]!
  "Serial number of the physical asset.\n[Source: PhysicalAsset]"
  serialNumber: String!
  "Tracked time for which the physical asset was used.\n[Source: PhysicalAsset]"
  timeUsageCounter: PhysicalAssetTimeUsageCounter!
  "Tracked output that the physical asset has produced.\n[Source: PhysicalAsset]"
  usageCounter: PhysicalAssetUsageCounter!
}

"Generic interface for physical asset defects."
interface PhysicalAssetDefect {
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
}

"Generic interface for physical asset history items."
interface PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
}

"Generic interface for produced job entities of all machine families."
interface ProducedJob {
  "Customer for which this job is produced.\n[Source: MachineSnapshots]"
  customer: SnapshotValuesDuringProductionOfString!
  "End timestamp of production in UTC (machine time) | This is 'null' if the job is active.\n[Source: ProductionPeriods]"
  endTime: DateTime
  "True, if the job is currently active.\n[Source: ProductionPeriods]"
  isActive: Boolean!
  "Id of produced job (unique for the machine)\n(The id of the produced job might be equal to the productionRequestId, but some machines add a suffix,\nfor example most printing presses behave like this: productionRequestId='JobA' =&gt; jobId='JobA-0023').\n[Source: ProductionPeriods]"
  jobId: String!
  "Target quantity to produce with this job.\n[Source: MachineSnapshots]"
  jobSize: NumericSnapshotValuesDuringProduction!
  "Unique identifier of the machine this job is produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: ProductionPeriods]"
  machineId: String!
  "The overall equipment effectiveness (OEE) is a measure that identifies the percentage of production time that is truly productive.\nThe OEE is calculated from three sub values (Availability, Effectiveness, Quality) which indicate how the productivity was lost.\nFor the comparison of jobs, the OEE has its weaknesses as the necessary setup time (which depends on the previous job) has a huge influence."
  overallEquipmentEffectiveness: OeeValues
  "Values that are measuring the productivity of a job (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values.\nTherefore, some values are 'null' when the related target values are not given for the job.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of jobs\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs).\n[Source: KPIs]"
  performance: ProducedPerformance
  "Id of the product which is produced (not the product definition).\nUsually, this is the article number.\n[Source: ProductionPeriods]"
  productId: String
  "Cumulated minutes the machine was in each production status during this job.\nAlso, the total times are provided.\n[Source: KPIs]"
  productionTimes: ProductionTimes
  "Time which the remaining production of this job is estimated to take (is 'null' for completed jobs).\nCalculated based on average machine speed during production and remaining quantity to produce.\n[Source: KPIs]"
  remainingProductionTimeInMin: Float
  "Start timestamp of production in UTC (machine time).\n[Source: ProductionPeriods]"
  startTime: DateTime!
  "The overall time the production of this job should take,\nwhich includes setup time, job-related downtimes and scrap losses.\nThis is the job size divided by the target value of the total good production rate,\nwhich is calculated by the target values for speed, scrap, downtime and setup.\nThis value is 'null', if there is no target value for speed, scrap or downtime.\nIf there is no expected setup time for this job, the actual setup time is taken.\n[Source: KPIs]"
  targetJobTimeInMin: Float
  "All time ranges in which this job was produced\n(excludes job breaks like weekends;\non active jobs the 'to' is the machine time at query moment).\n[Source: ProductionPeriods]"
  timeRanges: [TimeRange!]
  "Unique produced job identifier (in format MachineId_Job, like: \"EQ12345_JobA-1234\").\nThe machineId needs to be added, because it is possible that a job with the same name is produced on different machines.\n[Source: FrameworkAPI]"
  uniqueId: String!
}

"Abstract class for all EntryTypes of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
interface TrackHistoryEntry {
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"An anilox capability test result."
type AniloxCapabilityTestResult {
  "The type of the anilox error.\n[Source: AniloxCapabilityTestResult]"
  aniloxCapabilityErrorType: AniloxCapabilityErrorType!
  "Unique identifier of the capability test result.\n[Source: CapabilityTestResult]"
  capabilityTestResultId: String!
  "Unique identifier of the used capability test specification.\n[Source: CapabilityTestResult]"
  capabilityTestSpecificationId: String!
  "The end position on the anilox.\n[Source: AniloxCapabilityTestResult]"
  endPositionOnAnilox: Float
  "Specifies whether the test passed when it was compared against the specification.\n[Source: CapabilityTestResult]"
  isPassed: Boolean!
  "The additional note for this test result.\n[Source: CapabilityTestResult]"
  note: String
  "Unique identifier of the tested physical asset.\n[Source: CapabilityTestResult]"
  physicalAssetId: String!
  "The start position on the anilox.\n[Source: AniloxCapabilityTestResult]"
  startPositionOnAnilox: Float!
  "Date the physical asset was tested.\n[Source: CapabilityTestResult]"
  testDateTime: DateTime!
  "Id of the user who tested the physical asset.\n[Source: CapabilityTestResult]"
  testerUserId: String!
}

"An anilox capability test specification."
type AniloxCapabilityTestSpecification implements CapabilityTestSpecification {
  "The flag which signals if errors are always passing regardless of the test result.\n[Source: AniloxCapabilityTestSpecification]"
  alwaysPass: Boolean!
  "Unique identifier of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestSpecificationId: String!
  "Type of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestType: CapabilityTestType!
  "Date of the creation of the capability test specification.\n[Source: CapabilityTestSpecification]"
  createdAt: DateTime!
  "Description of the capability test specification.\n[Source: CapabilityTestSpecification]"
  description: String
  "Version of the capability test specification.\n[Source: CapabilityTestSpecification]"
  version: Int!
}

"An anilox physical asset."
type AniloxPhysicalAsset implements PhysicalAsset {
  "Date of the creation of the physical asset.\n[Source: PhysicalAsset]"
  createdAt: DateTime!
  "The defects of the physical asset.\n[Source: PhysicalAsset]"
  defects: [PhysicalAssetDefect!]
  "Date of the delivery of the physical asset.\n[Source: PhysicalAsset]"
  deliveredAt: DateTime
  "Description of the physical asset.\n[Source: PhysicalAsset]"
  description: String
  "Engraving of the anilox physical asset.\n[Source: AniloxPhysicalAsset]"
  engraving: String
  "Equipment the physical asset is currently equipped by e.g. machine.\n[Source: PhysicalAsset]"
  equippedBy: Equipment
  "The history of the physical asset.\n[Source: PhysicalAsset]"
  history: [PhysicalAssetHistoryItem!]
  "Initial time usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialTimeUsageCounter: Long
  "Initial usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialUsageCounter: Long
  "Inner diameter of the anilox physical asset.\n[Source: AniloxPhysicalAsset]"
  innerDiameter: ValueWithUnitOfDouble
  "Specifies whether the anilox physical asset is a sleeve or a roll.\n[Source: AniloxPhysicalAsset]"
  isSleeve: Boolean
  "Date of the last change to the metadata, tests or operations of the physical asset.\n[Source: PhysicalAsset]"
  lastChange: DateTime!
  "Last type of cleaning when the physical asset was last cleaned.\n[Source: PhysicalAsset]"
  lastCleaning: TrackedValueOfCleaningOperationType
  "Last consumed material when the physical asset was last used e.g. color.\n[Source: PhysicalAsset]"
  lastConsumedMaterial: TrackedValueOfString
  "Manufacturer of the physical asset.\n[Source: PhysicalAsset]"
  manufacturer: String
  "Optical density of the anilox physical asset with last measure and set value to test against.\n[Source: AniloxPhysicalAsset]"
  opticalDensity: TestableValueWithUnitOfDouble!
  "Outer diameter of the anilox physical asset.\n[Source: AniloxPhysicalAsset]"
  outerDiameter: ValueWithUnitOfDouble!
  "Unique identifier of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetId: String!
  "Type of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetType: PhysicalAssetType!
  "Preferred usage location (like: \"EQ12345\" or \"MIRAFLEX AM Dualport\") of the physical asset.\n[Source: PhysicalAsset]"
  preferredUsageLocation: String
  "Print width of the anilox physical asset.\n[Source: AniloxPhysicalAsset]"
  printWidth: ValueWithUnitOfDouble!
  "List of unique scan codes (e.g. QR codes) identifying the physical asset.\n[Source: PhysicalAsset]"
  scanCodes: [String!]!
  "Screen of the anilox physical asset.\n[Source: AniloxPhysicalAsset]"
  screen: ValueWithUnitOfInt32!
  "Serial number of the physical asset.\n[Source: PhysicalAsset]"
  serialNumber: String!
  "Tracked time for which the physical asset was used.\n[Source: PhysicalAsset]"
  timeUsageCounter: PhysicalAssetTimeUsageCounter!
  "Tracked output that the physical asset has produced.\n[Source: PhysicalAsset]"
  usageCounter: PhysicalAssetUsageCounter!
  "Volume of the anilox physical asset with last measure and set value to test against.\n[Source: AniloxPhysicalAsset]"
  volume: TestableValueWithUnitOfDouble!
}

type AverageSnapshotValue {
  "The unit of the value."
  unit: String
  "The average (arithmetic mean) value during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  value: Float
}

"A cleaning operation."
type CleaningOperation {
  "Type of the cleaning.\n[Source: CleaningOperation]"
  cleaningOperationType: CleaningOperationType!
  "Date the operation was ended.\n[Source: Operation]"
  endDateTime: DateTime
  "Unique identifier of the equipment physical asset mapping the operation is associated with.\n[Source: Operation]"
  equipmentPhysicalAssetMappingId: String!
  "The additional note for this operation.\n[Source: Operation]"
  note: String
  "Type of the operation.\n[Source: Operation]"
  operationType: OperationType!
  "Id of the user who carried out the operation.\n[Source: Operation]"
  operatorUserId: String!
  "Unique identifier of the physical asset the operation is associated with.\n[Source: Operation]"
  physicalAssetId: String!
  "The flag which signals if the cleaning resets past volume defects.\n[Source: CleaningOperation]"
  resetVolumeDefects: Boolean!
  "Date the operation was started.\n[Source: Operation]"
  startDateTime: DateTime!
}

"Information about the offset pagination."
type CollectionSegmentInfo {
  "Indicates whether more items exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more items exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
}

"Request item to create or edit a dashboard.\nAll widget settings will be overwritten - even if they are null."
type CreateOrEditConfiguredDashboardRequest {
  "The dashboard id of the dashboard to be edited or created."
  dashboardId: String
  "The WuH department this dashboards is dedicated for."
  department: MachineDepartment!
  "The friendly name of this dashboard which was given by the user.\nThere should not be two public dashboards with the same friendly name."
  friendlyName: String!
  "Is true, if all users can see this dashboard.\nIs false, if only the creator can see it."
  isPublic: Boolean!
  "Settings for the 1st widget.\nIf this is null, this widget is blank."
  widget1: DashboardWidgetSettings
  "Settings for the 2nd widget.\nIf this is null, this widget is blank."
  widget2: DashboardWidgetSettings
  "Settings for the 3rd widget.\nIf this is null, this widget is blank."
  widget3: DashboardWidgetSettings
  "Settings for the 4th widget.\nIf this is null, this widget is blank."
  widget4: DashboardWidgetSettings
  "Settings for the 5th widget.\nIf this is null, this widget is blank."
  widget5: DashboardWidgetSettings
  "Settings for the 6th widget.\nIf this is null, this widget is blank."
  widget6: DashboardWidgetSettings
}

type DashboardSettings {
  "Is true, if this dashboard can only be edited by the creator.\nThis setting can be used to prevent unwanted changes of a dashboard (for example in show cases).\nAs we don't have an admin interface to manage dashboards that were created by deleted users, this setting will always be false by default.\nFor show cases at trade fairs etc, it can be set in database."
  canOnlyBeEditedByCreator: Boolean!
  "The timestamp at which this dashboard was created."
  createdDate: DateTime!
  "The full name of the user that created this dashboard.\n[Source: Supervisor]"
  creatorFullName: String
  "The unique ID of the user that created this dashboard."
  creatorUserId: String!
  "Unique Identifier of this dashboard that was given by the database.\nIf this is null, the setting is not yet inserted into the database."
  dashboardId: String!
  "The WuH department this dashboards is dedicated for."
  department: MachineDepartment!
  "The friendly name of this dashboard which was given by the user.\nThere should not be two public dashboards with the same friendly name."
  friendlyName: String!
  "Is true, if all users can see this dashboard.\nIs false, if only the creator can see it."
  isPublic: Boolean!
  "The timestamp at which this dashboard was edited the last time.\nIs null, if this dashboard was never edited."
  lastEditedDate: DateTime
  "The full name of the user that edited this dashboard the last time.\nIs null, if this dashboard was never edited.\n[Source: Supervisor]"
  lastEditorFullName: String
  "The unique ID of the user that edited this dashboard the last time.\nIs null, if this dashboard was never edited."
  lastEditorUserId: String
  "Settings for the 1st widget.\nIf this is null, this widget is blank."
  widget1: DashboardWidgetSettings
  "Settings for the 2nd widget.\nIf this is null, this widget is blank."
  widget2: DashboardWidgetSettings
  "Settings for the 3rd widget.\nIf this is null, this widget is blank."
  widget3: DashboardWidgetSettings
  "Settings for the 4th widget.\nIf this is null, this widget is blank."
  widget4: DashboardWidgetSettings
  "Settings for the 5th widget.\nIf this is null, this widget is blank."
  widget5: DashboardWidgetSettings
  "Settings for the 6th widget.\nIf this is null, this widget is blank."
  widget6: DashboardWidgetSettings
}

type DashboardSettingsCreateDashboardPayload {
  dashboardSettings: DashboardSettings
  errors: [DashboardSettingsCreateDashboardError!]
}

type DashboardSettingsDeleteDashboardPayload {
  dashboardId: String
  errors: [DashboardSettingsDeleteDashboardError!]
}

type DashboardSettingsEditDashboardPayload {
  dashboardSettings: DashboardSettings
  errors: [DashboardSettingsEditDashboardError!]
}

type DashboardWidgetSettings {
  "An optional free text that can be used for specific widget settings."
  additionalSetting: String
  "List with unique machine identifiers (usually WuH equipment number, like: \"EQ12345\") of all machines that should be shown on this widget."
  machineIds: [String!]!
  "Reference to the entry in the frontend's widget catalog.\nThis is not a unique identifier for the widget instance:\nWidgets with the same WidgetCatalogId can be configured on the same or other dashboards but with different machine(s)."
  widgetCatalogId: String!
}

"An equipment an physical asset can equip."
type Equipment {
  "Description of the equipment.\n[Source: Equipment]"
  description: String
  "Unique identifier of the equipment.\n[Source: Equipment]"
  equipmentId: String!
  "Type of the equipmentType.\n[Source: Equipment]"
  equipmentType: EquipmentType!
}

"Values measured by sensors, quality measurements, actual values of machine settings, values calculated by PLC, ..."
type ExtrusionActualProcessValues {
  "The actual process values for the cage."
  cage: ExtrusionCage!
  "The actual process values for the bubble cooling."
  cooling: ExtrusionCooling!
  "The actual process values for extruder A."
  extruderA: ExtrusionExtruderA!
  "The actual process values for extruder B."
  extruderB: ExtrusionExtruderB!
  "The actual process values for extruder C."
  extruderC: ExtrusionExtruderC!
  "The actual process values for extruder D."
  extruderD: ExtrusionExtruderD!
  "The actual process values for extruder E."
  extruderE: ExtrusionExtruderE!
  "The actual process values for extruder F."
  extruderF: ExtrusionExtruderF!
  "The actual process values for extruder G."
  extruderG: ExtrusionExtruderG!
  "The actual process values for extruder H."
  extruderH: ExtrusionExtruderH!
  "The actual process values for extruder I."
  extruderI: ExtrusionExtruderI!
  "The actual process values for extruder J."
  extruderJ: ExtrusionExtruderJ!
  "The actual process values for extruder K."
  extruderK: ExtrusionExtruderK!
  "The actual process values for the haul-off."
  haulOff: ExtrusionHaulOff!
  "Current total power output.\n[Source: MachineSnapshot]"
  powerOutput: NumericSnapshotValue!
  "The actual process values for the reversing unit."
  reversingUnit: ExtrusionReversingUnit!
  "Current length of roll on winding station A.\n[Source: MachineSnapshot]"
  rollLengthA: NumericSnapshotValue!
  "Current length of roll on winding station B.\n[Source: MachineSnapshot]"
  rollLengthB: NumericSnapshotValue!
  "The amount of energy currently used to produce one kg of film.\n[Source: MachineSnapshot]"
  specificEnergy: NumericSnapshotValue!
  "Current film thickness.\nThis is always the value from the currently most relevant thickness measurement (Primary\/MDO\/...).\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current status for the primary thickness gauge. True = On, False = Off.\n[Source: MachineSnapshot]"
  thicknessGaugeStatus: SnapshotValueOfBoolean!
  "All profiles of the different thickness measurement systems.\nThese profiles show the current deviation of produced thickness as a profile over the produced width."
  thicknessProfiles: ExtrusionThicknessProfiles!
  "Current deviation of produced thickness from 2-sigma (in %).\nThis is always the value from the currently most relevant thickness measurement (Primary\/MDO\/...).\n[Source: MachineSnapshot]"
  twoSigma: NumericSnapshotValue!
  "Current width of the produced film.\nThis is always the value from the currently most relevant width measurement (Primary\/MDO\/...).\n[Source: MachineSnapshot]"
  width: NumericSnapshotValue!
  "Current status for the width controller.\n[Source: MachineSnapshot]"
  widthControllerStatus: SnapshotValueOfBoolean!
}

"All process parameters related to the cooling system."
type ExtrusionCage {
  "Current value for the height that the cage is at\n[Source: MachineSnapshot]"
  height: NumericSnapshotValue!
  "Current value for the width of the cage\n[Source: MachineSnapshot]"
  width: NumericSnapshotValue!
}

"All process parameters related to the cooling system."
type ExtrusionCooling {
  "Current value for the air that is blown out of the bubble\n[Source: MachineSnapshot]"
  innerAirExhaustControl: NumericSnapshotValue!
  "Current value for the air that is blown into the bubble.\n[Source: MachineSnapshot]"
  innerAirSupplyControl: NumericSnapshotValue!
  "Current value for the air that is blown around the bubble.\n[Source: MachineSnapshot]"
  outerAirControl: NumericSnapshotValue!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderA {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder A.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder A.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder A.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder A.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder A.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder A.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder A.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderASettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderB {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder B.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder B.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder B.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder B.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder B.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder B.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder B.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderBSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderC {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder C.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder C.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder C.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder C.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder C.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder C.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder C.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderCSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderD {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder D.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder D.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder D.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder D.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder D.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder D.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder D.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderDSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderE {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder E.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder E.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder E.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder E.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder E.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder E.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder E.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderESettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderF {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder F.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder F.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder F.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder F.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder F.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder F.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder F.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderFSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderG {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder G.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder G.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder G.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder G.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder G.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder G.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder G.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderGSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderH {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder H.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder H.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder H.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder H.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder H.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder H.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder H.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderHSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderI {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder I.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder I.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder I.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder I.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder I.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder I.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder I.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderISettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderJ {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder J.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder J.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder J.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder J.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder J.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder J.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder J.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderJSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionExtruderK {
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component1Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component2Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component3Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component4Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component5Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component6Percentage: NumericSnapshotValue!
  "Current value for percentage of this components material in relation to the total of the extruder\n[Source: MachineSnapshot]"
  component7Percentage: NumericSnapshotValue!
  "Current feedrate (kg\/60U) of extruder K.\n[Source: MachineSnapshot]"
  feedRate: NumericSnapshotValue!
  "Current motor load (%) of extruder K.\n[Source: MachineSnapshot]"
  motorLoad: NumericSnapshotValue!
  "Current pressure (bar) inside of extruder K.\n[Source: MachineSnapshot]"
  pressure: NumericSnapshotValue!
  "Current speed (RPM) of extruder K.\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValue!
  "Current melt temperature (°C) in extruder K.\n[Source: MachineSnapshot]"
  temperature: NumericSnapshotValue!
  "Current thickness (µm) of the film layer corresponding to extruder K.\n[Source: MachineSnapshot]"
  thickness: NumericSnapshotValue!
  "Current throughput (kg\/h) of extruder K.\n[Source: MachineSnapshot]"
  throughtput: NumericSnapshotValue!
}

"Extruder settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionExtruderKSettings {
  "Set value for the material name of component 1"
  component1MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 1"
  component1Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 2"
  component2MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 2"
  component2Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 3"
  component3MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 3"
  component3Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 4"
  component4MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 4"
  component4Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 5"
  component5MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 5"
  component5Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 6"
  component6MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 6"
  component6Percentage: NumericSnapshotValuesDuringProduction!
  "Set value for the material name of component 7"
  component7MaterialName: SnapshotValuesDuringProductionOfString!
  "Set value for the percentage of component 7"
  component7Percentage: NumericSnapshotValuesDuringProduction!
}

"All process parameters related to the cooling system."
type ExtrusionHaulOff {
  "Current value for the center guide.\n[Source: MachineSnapshot]"
  centerGuide: NumericSnapshotValue!
  "Current value for the collapser.\n[Source: MachineSnapshot]"
  collapser: NumericSnapshotValue!
}

"Machine entity of extrusion machines."
type ExtrusionMachine implements Machine {
  "Number of all alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  activeMachineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String): Long
  "All alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  activeMachineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 10): [MachineAlarm!]
  "The currently active machine alarm that was started first after the current problem occurred.\nIs null, if no alarm is active on the machine.\n[Source: AlarmDataHandler]"
  activePrimalMachineAlarm: MachineAlarm
  "Indicates which winding station is being used. 'A' or 'B' means that tube film is produced.\n[Source: MachineSnapshots]"
  activeWindingStation: SnapshotValueOfString!
  "Values measured by sensors, quality measurements, actual values of machine settings, values calculated by PLC, ...\n[Source: MachineSnapshot]"
  actualProcessValues: ExtrusionActualProcessValues!
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartment!
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeatures!
  "Status of licenses for RUBY extensions and connection modules.\n[Source: LicenseManager]"
  licenses: RubyLicenses
  "The line speed is the machines speed at the haul-off (blown film) respectively at the chill roll (cast film).\n[Source: MachineSnapshots]"
  lineSpeed: NumericSnapshotValueAndTrend!
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamily!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: String!
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: String!
  "The number of layers of the currently produced film.\n[Source: MachineSnapshots]"
  numberOfLayers: NumericSnapshotValueAndTrend!
  "Indicates whether MDO is used, side gussets are used or nothing special, which has an impact on the interpretation of widths, thicknesses and profiles.\n[Source: MachineSnapshots]"
  operatingMode: SnapshotValueOfString!
  "The job entity that is currently produced on the machine if no timestamp is provided.\nOtherwise the job entity that was active at the given timestamp."
  producedJob: ProducedJob
  "The current production status of the machine.\n[Source: MachineSnapshot]"
  productionStatus: ProductionStatus!
  "The current profile control mode\n[Source: MachineSnapshots]"
  profileControlMode: NumericSnapshotValueAndTrend!
  "Indicates which profile control mode should be used given the current operating mode.\n[Source: MachineSnapshots]"
  targetProfileControlMode: NumericSnapshotValueAndTrend!
  "The amount of raw material that is going into the extruders in a certain time measured by the gravimetric\n(in common parlance this is the 'machine speed').\n[Source: MachineSnapshots]"
  throughputRate: NumericSnapshotValueAndTrend!
  "Query timestamp is not provided:\nMachines OPC-UA server time and latest snapshot time are compared and the latest one is being returned.\n            \nQuery timestamp is provided:\nQuery timestamp is being returned.\n            \n[Source: Machines OPC-UA server time, latest snapshot or query timestamp]"
  time: DateTime
}

"Machine settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionMachineSettings {
  "Settings for extruder A."
  extruderA: ExtrusionExtruderASettings!
  "Settings for extruder B."
  extruderB: ExtrusionExtruderBSettings!
  "Settings for extruder C."
  extruderC: ExtrusionExtruderCSettings!
  "Settings for extruder D."
  extruderD: ExtrusionExtruderDSettings!
  "Settings for extruder E."
  extruderE: ExtrusionExtruderESettings!
  "Settings for extruder F."
  extruderF: ExtrusionExtruderFSettings!
  "Settings for extruder G."
  extruderG: ExtrusionExtruderGSettings!
  "Settings for extruder H."
  extruderH: ExtrusionExtruderHSettings!
  "Settings for extruder I."
  extruderI: ExtrusionExtruderISettings!
  "Settings for extruder J."
  extruderJ: ExtrusionExtruderJSettings!
  "Settings for extruder K."
  extruderK: ExtrusionExtruderKSettings!
  "Settings for MDO."
  mdo: ExtrusionMdoSettings!
  "The order of layers - \"the output of which extruder goes into what layer\". Also called plug code."
  orderOfLayers: SnapshotValuesDuringProductionOfString!
  "Set value for the reversing time.\n[Source: MachineSnapshot]"
  reversingTime: NumericSnapshotValuesDuringProduction!
  "Set value of the roll length for winding station A."
  rollLengthA: NumericSnapshotValuesDuringProduction!
  "Set value of the roll length for winding station B."
  rollLengthB: NumericSnapshotValuesDuringProduction!
  "Set value of the product thickness."
  thickness: NumericSnapshotValuesDuringProduction!
  "Set value of the product width. Depending on the operating mode this can be the primary, secondary or winding width (set)."
  width: NumericSnapshotValuesDuringProduction!
}

"Machine time span entity of extrusion machines."
type ExtrusionMachineTimeSpan implements MachineTimeSpan {
  "The start timestamp of the query.\n[Source: Query]"
  from: DateTime!
  "Meters of produced output in acceptable quality within this time span.\n[Source: MachineSnapshots]\n\n\n**Returns:**\ndouble"
  goodLength: SummedSnapshotValue
  "Kilograms of produced output in acceptable quality within this time span.\nTogether with the ScrapWeightDuringProduction and ScrapWeightDuringSetup this is the total raw material consumption within this time span.\n[Source: MachineSnapshots]"
  goodWeight: SummedSnapshotValue
  "Machines line speed during the time span.\nThe line speed is the speed at the haul-off (blown film) respectively at the chill roll (cast film).\n[Source: MachineSnapshots]"
  lineSpeed: NumericSnapshotValuesDuringProduction!
  "Number of alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  machineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String "If set, only the alarms are counted that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false): Long
  "Alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  machineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "If set, only the alarms are returned that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 100): [MachineAlarm!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Consumption of extruded raw material during this time span grouped by material name.\nThe material names are entered in ProControl (machine HMI) for each component.\nThe material consumption is measured for each component by machine.\nWith this data first the material consumption per material name is calculated for each component.\nThen the consumption per material name is summed-up from all components and returned.\n[Source: MachineSnapShooter]\n\n\n**Returns:**\nDictionary (key: material name; value: consumption)"
  rawMaterialConsumptionByMaterial: [KeyValuePairOfStringAndNumericValue!]
  "Meters of produced output in not-acceptable quality (= scrap\/waste) within this time span.\n[Source: MachineSnapshots]"
  scrapLength: SummedSnapshotValue
  "Kilograms of produced output in not-acceptable quality (= scrap\/waste) within this time span in production.\nTogether with the GoodWeight and ScrapWeightDuringSetup this is the total raw material consumption within this time span.\n[Source: MachineSnapshots]"
  scrapWeightDuringProduction: SummedSnapshotValue
  "Kilograms of produced output in not-acceptable quality (= scrap\/waste) within this time span in setup.\nTogether with the GoodWeight and ScrapWeightDuringProduction this is the total raw material consumption within this time span.\n[Source: MachineSnapshots]"
  scrapWeightDuringSetup: SummedSnapshotValue
  "Returns all shifts during the query time span.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: Settings + ProductionPeriods (for operators)]"
  shifts: [MachineShift!]
  "The target throughput rate during the time span.\nThe origin of the value can be different (priority is 1-3):\n1.) Job-specific value defined in customer system (via Connect 4 Flow)\n2.) Value entered in ProControl (ProcessData)\n3.) Default setting (via Track section in Admin)\n[Source: MachineSnapshots]"
  targetThroughputRate: NumericSnapshotValuesDuringProduction
  "Machines throughput rate during the time span.\nThe throughput rate is the amount of raw material that is going into the extruders in a certain time measured by the gravimetric\n(in common parlance this is the 'machine speed').\n[Source: MachineSnapshots]"
  throughputRate: NumericSnapshotValuesDuringProduction!
  "The end timestamp of the query.\n[Source: Query]"
  to: DateTime!
}

"Machine settings during an extrusion job (all properties should be derived from MachineSnapshots)."
type ExtrusionMdoSettings {
  "Set value for the secondary thickness, which is the thickness after the film exits the MDO and has been stretched."
  thicknessSecondary: SnapshotValuesDuringProductionOfString!
  "Set value of the secondary width, which is the width after the film exits the MDO and has been stretched."
  widthSecondary: NumericSnapshotValuesDuringProduction!
}

"Produced job entity of extrusion machines."
type ExtrusionProducedJob implements ProducedJob {
  "Average throughput rate during all time-ranges the machine was in production within this job.\n[Source: KPIs]"
  averageThroughputRateDuringProduction: NumericValue!
  "Customer for which this job is produced.\n[Source: MachineSnapshots]"
  customer: SnapshotValuesDuringProductionOfString!
  "End timestamp of production in UTC (machine time) | This is 'null' if the job is active.\n[Source: ProductionPeriods]"
  endTime: DateTime
  "Meters of produced output in acceptable quality within this job.\n[Source: KPIs]"
  goodLength: NumericValue!
  "Kilograms of produced output in acceptable quality within this job.\nTogether with the 'ScrapWeight' this is the total raw material consumption within this job.\n[Source: KPIs]"
  goodWeight: NumericValue!
  "True, if the job is currently active.\n[Source: ProductionPeriods]"
  isActive: Boolean!
  "Id of produced job (unique for the machine)\n(The id of the produced job might be equal to the productionRequestId, but some machines add a suffix,\nfor example most printing presses behave like this: productionRequestId='JobA' =&gt; jobId='JobA-0023').\n[Source: ProductionPeriods]"
  jobId: String!
  "Target quantity to produce with this job.\n[Source: MachineSnapshots]"
  jobSize: NumericSnapshotValuesDuringProduction!
  "Unique identifier of the machine this job is produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: ProductionPeriods]"
  machineId: String!
  "Machine settings during this job.\n[Source: MachineSnapshot]"
  machineSettings: ExtrusionMachineSettings!
  "The overall equipment effectiveness (OEE) is a measure that identifies the percentage of production time that is truly productive.\nThe OEE is calculated from three sub values (Availability, Effectiveness, Quality) which indicate how the productivity was lost.\nFor the comparison of jobs, the OEE has its weaknesses as the necessary setup time (which depends on the previous job) has a huge influence."
  overallEquipmentEffectiveness: OeeValues
  "Values that are measuring the productivity of a job (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values.\nTherefore, some values are 'null' when the related target values are not given for the job.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of jobs\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs).\n[Source: KPIs]"
  performance: ProducedPerformance
  "Id of the product which is produced (not the product definition).\nUsually, this is the article number.\n[Source: ProductionPeriods]"
  productId: String
  "Cumulated minutes the machine was in each production status during this job.\nAlso, the total times are provided.\n[Source: KPIs]"
  productionTimes: ProductionTimes
  "Consumption of extruded raw material during the jobs time ranges grouped by material name.\nThe material names are entered in ProControl (machine HMI) for each component.\nThe material consumption is measured for each component by machine.\nWith this data first the material consumption per material name is calculated for each component.\nThen the consumption per material name is summed-up from all components and returned.\nIt is not possible to get the material consumption for the current job via subscription.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: MachineSnapShooter]\n\n\n**Returns:**\nDictionary (key: material name; value: consumption)"
  rawMaterialConsumptionByMaterial: [KeyValuePairOfStringAndNumericValue!]
  "Time which the remaining production of this job is estimated to take (is 'null' for completed jobs).\nCalculated based on average machine speed during production and remaining quantity to produce.\n[Source: KPIs]"
  remainingProductionTimeInMin: Float
  "Meters of produced output in not-acceptable quality (= scrap\/waste) within this job.\nThis includes 'SetupScrapLength'.\n[Source: KPIs]"
  scrapLength: NumericValue!
  "Kilograms of produced output in not-acceptable quality (= scrap\/waste) within this job.\nTogether with the 'GoodWeight' this is the total raw material consumption within this job.\nThis includes 'SetupScrapWeight'.\n[Source: KPIs]"
  scrapWeight: NumericValue!
  "Meters of produced output in not-acceptable quality (= scrap\/waste) during setup of this job.\nThis is a sub-set of 'ScrapLength'.\n[Source: KPIs]"
  setupScrapLength: NumericValue!
  "Kilograms of produced output in not-acceptable quality (= scrap\/waste) during setup of this job.\nThis is a sub-set of 'ScrapWeight'.\n[Source: KPIs]"
  setupScrapWeight: NumericValue!
  "Start timestamp of production in UTC (machine time).\n[Source: ProductionPeriods]"
  startTime: DateTime!
  "The overall time the production of this job should take,\nwhich includes setup time, job-related downtimes and scrap losses.\nThis is the job size divided by the target value of the total good production rate,\nwhich is calculated by the target values for speed, scrap, downtime and setup.\nThis value is 'null', if there is no target value for speed, scrap or downtime.\nIf there is no expected setup time for this job, the actual setup time is taken.\n[Source: KPIs]"
  targetJobTimeInMin: Float
  "The target throughput rate of this job, which is usually defined by the production planning department.\nThe origin of the value can be different (priority is 1-3):\n1.) Job-specific value defined in customer system (via Connect 4 Flow)\n2.) Value entered in ProControl (ProcessData)\n3.) Default setting (via Track section in Admin)\n[Source: KPIs]"
  targetThroughputRate: NumericValue!
  "All time ranges in which this job was produced\n(excludes job breaks like weekends;\non active jobs the 'to' is the machine time at query moment).\n[Source: ProductionPeriods]"
  timeRanges: [TimeRange!]
  "Unique produced job identifier (in format MachineId_Job, like: \"EQ12345_JobA-1234\").\nThe machineId needs to be added, because it is possible that a job with the same name is produced on different machines.\n[Source: FrameworkAPI]"
  uniqueId: String!
}

"Produced roll entity of extrusion machines."
type ExtrusionProducedRoll implements MaterialLot {
  "End timestamp of production in UTC (machine time) | This is 'null' if the roll is currently produced.\n[Source: MaterialDataHandler]"
  endTime: DateTime
  "ID of the job for which this lot was\/is produced\n[Source: MachineSnapshots]"
  jobId: String!
  "The machine this material lot was produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: MaterialDataHandler]"
  machineId: String!
  "Unique identifier of the material lot\n(All material lots produced on WuH machines are identified by a UID:\nThe UID contains 5 characters indicating the manufacturer,\n6 digits for the commissioning number, UTC time in the format \"yyyymmddhhmmss\"\nand 2 digits for roll number in roll set).\n[Source: MaterialDataHandler]"
  materialLotId: String!
  "Quantity of product contained within the material lot (e.g. length of the roll).\n[Source: MaterialDataHandler]"
  quantity(machineId: String!): NumericValue!
  "Start timestamp of production in UTC (machine time).\n[Source: MaterialDataHandler]"
  startTime: DateTime!
  "Actual thickness of the film on this roll.\nCan be average 2-sigma value or average value.\n[Source: MachineSnapshots]"
  thicknessActual: Thickness!
}

"All process parameters related to the cooling system."
type ExtrusionReversingUnit {
  "Current position for the reversing unit.\n[Source: MachineSnapshot]"
  position: NumericSnapshotValue!
  "Status of the reversing unit (on\/off).\n[Source: MachineSnapshot]"
  status: SnapshotValueOfBoolean!
}

"Current deviation of produced thickness as a profile over the produced width."
type ExtrusionThicknessProfile {
  "The thickness profile can be controlled by different control elements over the produced width\n(this is 'null', if the 'ExtrusionThicknessMeasurementType' is not 'Primary' as the controlling of the other profiles is more complex).\nThis dictionary contains the data points that describe the control elements profile:\nkey =&gt; position (X axis)\nvalue =&gt; duty cycle of the heating element from 0 to 100 % (Y axis)\n(the data points on cast film machines are down sampled to 480)\n[Source: ProcessData]"
  controlElements: [KeyValuePairOfInt32AndDouble!]
  "The current deviation of produced thickness as a profile over the produced width.\nThis dictionary contains the data points that describe the thickness profile:\nkey =&gt; position (X axis)\nvalue =&gt; deviation from mean at position in % (Y axis)\n(the data points on cast film machines are down sampled to 480)\n[Source: ProcessData]"
  dataPoints: [KeyValuePairOfInt32AndDouble!]
  "Number of data points to expect.\n(is 360 on blow film and 480 on cast film lines).\n[Source: ProcessData]"
  dataPointsCount: Int!
  "Is true, if the controller that is using this thickness measurement is turned on.\n- Logic for 'Primary': Thickness gauge is on AND profile control mode is on but not 'MDO'.\n- Logic for 'MdoWinderA': Winder A has contact pressure AND profile control mode is 'MDO'.\n- Logic for 'MdoWinderB': Winder B has contact pressure AND profile control mode is 'MDO'.\n[Source: ProcessData]"
  isControllerOn: Boolean
  "Mean value of the profile measurement.\n[Source: ProcessData, MetaDataHandler]"
  meanValue: NumericValue
  "Timestamp of the sampling of the profile."
  timestamp: DateTime
  "2-sigma deviation from the mean value of the profile measurement (in %).\n[Source: ProcessData, MetaDataHandler]"
  twoSigma: NumericValue
  "Describes which of the different thickness measurement systems is used.\n[Source: FrameworkAPI]"
  type: ExtrusionThicknessMeasurementType
  "Unit of the position values.\n(is '°' on blow film and '' on cast film lines).\n[Source: MetaDataHandler]"
  xAxisUnit: String
}

"All profiles of the different thickness measurement systems.\nThese profiles show the current deviation of produced thickness as a profile over the produced width."
type ExtrusionThicknessProfiles {
  "The profile of the thickness measurement after the MDO before winding station A."
  mdoProfileA: ExtrusionThicknessProfile
  "The profile of the thickness measurement after the MDO before winding station B."
  mdoProfileB: ExtrusionThicknessProfile
  "The profile of the most relevant thickness measurement.\nLogic:\n- Is 'Primary' if profile control mode is not 'MDO'.\n- Is 'MdoWinderA' if profile control mode is 'MDO' and winder A has contact pressure.\n- Is 'MdoWinderB' if profile control mode is 'MDO' and winder A has no contact pressure."
  mostRelevantProfile: ExtrusionThicknessProfile
  "The profile of the primary thickness measurement."
  primaryProfile: ExtrusionThicknessProfile
}

"Settings for the whole RUBY instance."
type GlobalSettings {
  "Is the connection to the RUBY Cloud allowed?\n[Source: Setting in Admin]"
  isRubyCloudEnabled: Boolean
  "Is user behavior tracking (Matomo) enabled?"
  isUserBehaviorTrackingEnabled: Boolean
  "Friendly name of the RUBY instance.\n[Source: Setting in Admin]"
  rubyFriendlyName: String
  "Time zone of the RUBY instance and (if everything is set-up properly) of the connected machines.\n[Source: Setting in Admin]"
  rubyTimeZone: String
  "NTP server to sync the time.\n[Source: Setting in Admin]"
  rubyTimeZoneIpAddressWithPort: String
  "Flag if the time zone is in daylight saving time.\n[Source: Setting in Admin]"
  rubyTimeZoneIsDayLightSavingTime: Boolean
  "URL of the Matomo server.\n[Source: Hard-coded in backend]"
  userBehaviorTrackingUrl: String
}

type GlobalSettingsChangeRubyCloudEnabledPayload {
  cloudEnabled: Boolean
  errors: [GlobalSettingsChangeRubyCloudEnabledError!]
}

type GlobalSettingsChangeRubyFriendlyNamePayload {
  errors: [GlobalSettingsChangeRubyFriendlyNameError!]
  rubyFriendlyName: String
}

type GlobalSettingsChangeRubyUserBehaviorTrackingEnabledPayload {
  errors: [GlobalSettingsChangeRubyUserBehaviorTrackingEnabledError!]
  userBehaviorTrackingEnabled: Boolean
}

type GlobalSettingsChangeTimeZoneIpAddressWithPortPayload {
  errors: [GlobalSettingsChangeTimeZoneIpAddressWithPortError!]
  timeZoneIoAddressWithPort: String
}

type GlobalSettingsChangeTimeZonePayload {
  errors: [GlobalSettingsChangeTimeZoneError!]
  timeZone: String
}

type GlobalSettingsChangeUserBehaviorTrackingUrlPayload {
  errors: [GlobalSettingsChangeUserBehaviorTrackingUrlError!]
  userBehaviorTrackingUrl: String
}

type IdNotFoundError implements Error {
  message: String!
}

type InternalServiceError implements Error {
  message: String!
  statusCode: Int!
}

type KeyValuePairOfInt32AndDouble {
  key: Int!
  value: Float!
}

type KeyValuePairOfStringAndNumericValue {
  key: String!
  value: NumericValue!
}

type KeyValuePairOfStringAndPaperSackProductGroupStatisticsPerMachine {
  key: String!
  value: PaperSackProductGroupStatisticsPerMachine!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type MachineAlarm {
  "The combined code of this alarm (Format: ModuleId-AlarmNumber)."
  alarmCode: String!
  "The severity of this alarm as a localized text."
  alarmLevel: String!
  "The localized description of this alarm number."
  alarmText: String!
  "The timestamp this alarm ended on the machine.\nIf null, this alarm is still active."
  end: DateTime
  "The internal ObjectId of this alarm."
  id: String!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine this alarm occurred on.\n[Source: Machine]"
  machineId: String!
  "The localized name of the machine module this alarm is related to."
  moduleName: String!
  "The timestamp this alarm started on the machine."
  start: DateTime!
}

type MachineFeatures {
  "Version of the AlarmHandling feature if HasAlarmHandlingFeature is true, otherwise null."
  alarmHandlingFeatureVersion: Int
  "Version of the BarcodeCheck feature if HasBarcodeCheckFeature is true, otherwise null."
  barcodeCheckFeatureVersion: Int
  "Version of the BrowserOverlay feature if HasBrowserOverlayFeature is true, otherwise null."
  browserOverlayFeatureVersion: Int
  "Version of the Check feature if HasCheckFeature is true, otherwise null."
  checkFeatureVersion: Int
  "Version of the DefectCheck feature if HasDefectCheckFeature is true, otherwise null."
  defectCheckFeatureVersion: Int
  "Version of the Flow feature if HasFlowFeature is true, otherwise null."
  flowFeatureVersion: Int
  "Flag if machine has the AlarmHandling feature."
  hasAlarmHandlingFeature: Boolean!
  "Flag if machine has the BarcodeCheck feature."
  hasBarcodeCheckFeature: Boolean!
  "Flag if machine has the BrowserOverlay feature."
  hasBrowserOverlayFeature: Boolean!
  "Flag if machine has the Check feature."
  hasCheckFeature: Boolean!
  "Flag if machine has the DefectCheck feature."
  hasDefectCheckFeature: Boolean!
  "Flag if machine has the Flow feature."
  hasFlowFeature: Boolean!
  "Flag if machine has the Material feature."
  hasMaterialFeature: Boolean!
  "Flag if machine has the Messaging feature."
  hasMessagingFeature: Boolean!
  "Flag if machine has the PDFCheck feature."
  hasPdfCheckFeature: Boolean!
  "Flag if machine has the PDFCheckPackageTransfer feature."
  hasPdfCheckPackageTransferFeature: Boolean!
  "Flag if machine has the ProcessData feature."
  hasProcessDataFeature: Boolean!
  "Flag if machine has the ProductionPeriods feature."
  hasProductionPeriodsFeature: Boolean!
  "Flag if machine has the RgbLabCheck feature."
  hasRgbLabCheckFeature: Boolean!
  "Version of the Material feature if HasMaterialFeature is true, otherwise null."
  materialFeatureVersion: Int
  "Version of the Messaging feature if HasMessagingFeature is true, otherwise null."
  messagingFeatureVersion: Int
  "Version of the PDFCheck feature if HasPdfCheckFeature is true, otherwise null."
  pdfCheckFeatureVersion: Int
  "Version of the PDFCheckPackageTransfer feature if HasPdfCheckPackageTransferFeature is true, otherwise null."
  pdfCheckPackageTransferFeatureVersion: Int
  "Version of the ProcessData feature if HasProcessDataFeature is true, otherwise null."
  processDataFeatureVersion: Int
  "Version of the ProductionPeriods feature if HasProductionPeriodsFeature is true, otherwise null."
  productionPeriodsFeatureVersion: Int
  "Version of the RgbLabCheck feature if HasRgbLabCheckFeature is true, otherwise null."
  rgbLabCheckFeatureVersion: Int
}

"An actual shift, derived from the shift and time zone settings.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'."
type MachineShift {
  "End timestamp of the shift in UTC.\nIf this shift is currently active, this will be the machine time."
  endTime: DateTime!
  "Name of the user that was logged-in during the shift at the Operator UI.\nUsers that login for the first time in the 30 minutes before the shift change,\nwill be mapped to the following shift."
  mainOperatorName: String
  "Friendly name for the shift that is entered by the user.\nThis name does not need to be localized as the user will enter the name in it's language."
  shiftName: String!
  "Start timestamp of the shift in UTC."
  startTime: DateTime!
}

"A segment of a collection."
type MaterialLotsCollectionSegment {
  "A flattened list of the items."
  items: [MaterialLot!]
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

"Manages configured dashboards."
type Mutation @authorize {
  "Mutation to create a dashboard.\nThe user id of the creator.\nThe dashboard settings service.\nDashboard settings.\nCancellation token."
  dashboardSettingsCreateDashboard(input: DashboardSettingsCreateDashboardInput!): DashboardSettingsCreateDashboardPayload!
  "Mutation to delete a dashboard.\nThe user id of the deleter.\nThe dashboard settings service.\nId of the dashboard.\nCancellation token."
  dashboardSettingsDeleteDashboard(input: DashboardSettingsDeleteDashboardInput!): DashboardSettingsDeleteDashboardPayload!
  "Mutation to edit a dashboard.\nThe user id of the editor.\nThe dashboard settings service.\nDashboard settings.\nCancellation token."
  dashboardSettingsEditDashboard(input: DashboardSettingsEditDashboardInput!): DashboardSettingsEditDashboardPayload!
  "Mutation to change the flag which signals if the cloud is enabled.\nThe user settings service.\nThe flag which signals if the cloud is enabled."
  globalSettingsChangeRubyCloudEnabled(input: GlobalSettingsChangeRubyCloudEnabledInput!): GlobalSettingsChangeRubyCloudEnabledPayload! @authorize(roles: [ "admin" ])
  "Mutation to change friendly name of the ruby instance.\nThe user settings service.\nThe ruby friendly name."
  globalSettingsChangeRubyFriendlyName(input: GlobalSettingsChangeRubyFriendlyNameInput!): GlobalSettingsChangeRubyFriendlyNamePayload! @authorize(roles: [ "admin" ])
  "Mutation to change the flag which signals if the user behavior tracking is enabled.\nThe user settings service.\nThe flag which signals if the user behavior tracking is enabled."
  globalSettingsChangeRubyUserBehaviorTrackingEnabled(input: GlobalSettingsChangeRubyUserBehaviorTrackingEnabledInput!): GlobalSettingsChangeRubyUserBehaviorTrackingEnabledPayload! @authorize(roles: [ "go-general" ])
  "Mutation to change time zone of the ruby instance.\nThe user settings service.\nThe time zone."
  globalSettingsChangeTimeZone(input: GlobalSettingsChangeTimeZoneInput!): GlobalSettingsChangeTimeZonePayload! @authorize(roles: [ "admin" ])
  "Mutation to change the ntp server of the ruby instance.\nThe user settings service.\nThe ntp server with ip and port."
  globalSettingsChangeTimeZoneIpAddressWithPort(input: GlobalSettingsChangeTimeZoneIpAddressWithPortInput!): GlobalSettingsChangeTimeZoneIpAddressWithPortPayload! @authorize(roles: [ "admin" ])
  "Mutation to change the url tracking is send to if enabled.\nThe user settings service.\nThe url tracking data is send to."
  globalSettingsChangeUserBehaviorTrackingUrl(input: GlobalSettingsChangeUserBehaviorTrackingUrlInput!): GlobalSettingsChangeUserBehaviorTrackingUrlPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateAnilox(input: PhysicalAssetsCreateAniloxInput!): PhysicalAssetsCreateAniloxPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateAniloxCapabilityTestResult(input: PhysicalAssetsCreateAniloxCapabilityTestResultInput!): PhysicalAssetsCreateAniloxCapabilityTestResultPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateCleaningOperation(input: PhysicalAssetsCreateCleaningOperationInput!): PhysicalAssetsCreateCleaningOperationPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateRefurbishingAniloxOperation(input: PhysicalAssetsCreateRefurbishingAniloxOperationInput!): PhysicalAssetsCreateRefurbishingAniloxOperationPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateScrappingOperation(input: PhysicalAssetsCreateScrappingOperationInput!): PhysicalAssetsCreateScrappingOperationPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsCreateVolumeCapabilityTestResult(input: PhysicalAssetsCreateVolumeCapabilityTestResultInput!): PhysicalAssetsCreateVolumeCapabilityTestResultPayload! @authorize(roles: [ "go-general" ])
  physicalAssetsUpdateAnilox(input: PhysicalAssetsUpdateAniloxInput!): PhysicalAssetsUpdateAniloxPayload! @authorize(roles: [ "go-general" ])
  physicalAssetUpdateSettings(input: PhysicalAssetUpdateSettingsInput!): PhysicalAssetUpdateSettingsPayload! @authorize(roles: [ "go-general" ])
  producedJobChangeMachineTargetDownTimeInMin(input: ProducedJobChangeMachineTargetDownTimeInMinInput!): ProducedJobChangeMachineTargetDownTimeInMinPayload! @authorize(roles: [ "go-general" ])
  producedJobChangeMachineTargetScrapCountDuringProduction(input: ProducedJobChangeMachineTargetScrapCountDuringProductionInput!): ProducedJobChangeMachineTargetScrapCountDuringProductionPayload! @authorize(roles: [ "go-general" ])
  producedJobChangeMachineTargetSetupTimeInMin(input: ProducedJobChangeMachineTargetSetupTimeInMinInput!): ProducedJobChangeMachineTargetSetupTimeInMinPayload! @authorize(roles: [ "go-general" ])
  producedJobChangeMachineTargetSpeed(input: ProducedJobChangeMachineTargetSpeedInput!): ProducedJobChangeMachineTargetSpeedPayload! @authorize(roles: [ "go-general" ])
  productGroupChangeMachineNote(input: ProductGroupChangeMachineNoteInput!): ProductGroupChangeMachineNotePayload! @authorize(roles: [ "go-general" ])
  productGroupChangeMachineTargetSpeed(input: ProductGroupChangeMachineTargetSpeedInput!): ProductGroupChangeMachineTargetSpeedPayload! @authorize(roles: [ "go-general" ])
  productGroupChangeOverallNote(input: ProductGroupChangeOverallNoteInput!): ProductGroupChangeOverallNotePayload! @authorize(roles: [ "go-general" ])
  "Mutation to change preferred machine family for extrusion business unit of a user.\nThe user id.\nThe user settings service.\nThe preferred machine family."
  userSettingsChangeExtrusionMachineFamily(input: UserSettingsChangeExtrusionMachineFamilyInput!): UserSettingsChangeExtrusionMachineFamilyPayload!
  "Mutation to change the favorite dashboard of a user for extrusion department.\nThe user id.\nThe user settings service.\nThe dashboard settings service.\nThe database id of the new favorite dashboard.\nCancellation token."
  userSettingsChangeFavoriteDashboardExtrusion(input: UserSettingsChangeFavoriteDashboardExtrusionInput!): UserSettingsChangeFavoriteDashboardExtrusionPayload!
  "Mutation to change the favorite dashboard of a user for other departments.\nThe user id.\nThe user settings service.\nThe dashboard settings service.\nThe database id of the new favorite dashboard.\nCancellation token."
  userSettingsChangeFavoriteDashboardOther(input: UserSettingsChangeFavoriteDashboardOtherInput!): UserSettingsChangeFavoriteDashboardOtherPayload!
  "Mutation to change the favorite dashboard of a user for papersack department.\nThe user id.\nThe user settings service.\nThe dashboard settings service.\nThe database id of the new favorite dashboard.\nCancellation token."
  userSettingsChangeFavoriteDashboardPaperSack(input: UserSettingsChangeFavoriteDashboardPaperSackInput!): UserSettingsChangeFavoriteDashboardPaperSackPayload!
  "Mutation to change the favorite dashboard of a user for printing department.\nThe user id.\nThe user settings service.\nThe dashboard settings service.\nThe database id of the new favorite dashboard.\nCancellation token."
  userSettingsChangeFavoriteDashboardPrinting(input: UserSettingsChangeFavoriteDashboardPrintingInput!): UserSettingsChangeFavoriteDashboardPrintingPayload!
  "Mutation to change language of a user.\nThe user id.\nThe user settings service.\nThe preferred user language."
  userSettingsChangeLanguage(input: UserSettingsChangeLanguageInput!): UserSettingsChangeLanguagePayload!
  "Mutation to change preferred machine department of a user.\nThe user id.\nThe user settings service.\nThe preferred machine department."
  userSettingsChangeMachineDepartment(input: UserSettingsChangeMachineDepartmentInput!): UserSettingsChangeMachineDepartmentPayload!
  "Mutation to change preferred machine family for other business unit of a user.\nThe user id.\nThe user settings service.\nThe preferred machine family."
  userSettingsChangeOtherMachineFamily(input: UserSettingsChangeOtherMachineFamilyInput!): UserSettingsChangeOtherMachineFamilyPayload!
  "Mutation to change preferred machine family for paper sack business unit of a user.\nThe user id.\nThe user settings service.\nThe preferred machine family."
  userSettingsChangePaperSackMachineFamily(input: UserSettingsChangePaperSackMachineFamilyInput!): UserSettingsChangePaperSackMachineFamilyPayload!
  "Mutation to change preferred machine family for printing business unit of a user.\nThe user id.\nThe user settings service.\nThe preferred machine family."
  userSettingsChangePrintingMachineFamily(input: UserSettingsChangePrintingMachineFamilyInput!): UserSettingsChangePrintingMachineFamilyPayload!
  "Mutation to change preferred unit system of a user.\nThe user id.\nThe user settings service.\nThe preferred user unit system."
  userSettingsChangeUnitSystem(input: UserSettingsChangeUnitSystemInput!): UserSettingsChangeUnitSystemPayload!
}

"The value of a numeric variable.\nThis is only supported for values that can be derived from MachineSnapshots."
type NumericSnapshotValue {
  "The last known value of the variable before the query timestamp\n(if the query timestamp is 'null', this is the live-value)"
  lastValue: Float
  "The unit of the last value\n(if the unit needs to be translated, the corresponding i18n tag is provided here; for example 'label.items')."
  unit: String
}

"The value of a numeric variable and the trend of the last 8-hours.\nThis is only supported for values that can be derived from MachineSnapshots."
type NumericSnapshotValueAndTrend {
  "The trend of the last 8 hours. It is represented by trend elements each consisting of a time and a value. The\ntrend elements are sorted by the time (ascending) and 481 (8 hours * 60 minutes + 1 minute) trend elements will\nalways be returned (if no error occurred). The whole trend will be filled with a null value for each minute if\nthere are no snapshots. Everything up to the first trend element (exclusive) will be filled with a null value\nfor each minute if there are less than 481 snapshots. Gaps after existing trend elements should never exist\nbecause the MachineSnapShooter returns snapshots only after all snapshots have been created based on the\nhistorical data.\n            \nTrend interval:\n- Query timestamp is not provided\n  - Start: Machine time - 8 hours\n  - End: Machine time\n- Query timestamp is provided\n  - Start: Query timestamp - 8 hours\n  - End: Query timestamp"
  trendOfLast8Hours: [NumericTrendElement!]
  "The unit of the value\n(if the unit needs to be translated, the corresponding i18n tag is provided here; for example 'label.items')."
  unit: String
  "The numeric value in SI unit\n(is 'null', if this data is currently not available)."
  value: Float
}

"The values of a numeric variable (for example a set value) can be changed during production of a job\/roll\/time-span,\nIn these cases it is not always easy to determine just one single value for the variable that stands for the whole job\/roll\/time-span\nThis data model provides more information, so the user might get an indication if the value was changed during the job\/roll\/time-span\nThis is only supported for values that can be derived from MachineSnapshots."
type NumericSnapshotValuesDuringProduction {
  "The average (arithmetic mean) value during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  averageValue: Float
  "All distinct values that were present during the job\/roll\/time-span in SI units.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  distinctValues(limit: Int! = 100): [Float]
  "The value on the end of the job\/roll\/time-span in SI unit.\nIf the job\/roll\/time-span is still active, this is the current live-value."
  lastValue: Float
  "The maximal value across all values during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  maxValue: Float
  "The value with the longest duration during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  median: Float
  "The minimum value across all values during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  minValue: Float
  "The standard deviation of all values during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  standardDeviationValue: Float
  "The trend of the values during the job\/roll\/time-span in SI unit.\nIt is represented by trend elements each consisting of a time and a value.\nThe trend elements are sorted by the time (ascending).\nThe trend will contain one element for each minute in the job\/roll\/time-span.\nIf a job or roll with multiple time ranges is queried this trend contains also the data between these time ranges.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  trend: [NumericTrendElement!]
  "The unit of the values\n(if the unit needs to be translated, the corresponding i18n tag is provided here; for example 'label.items')."
  unit: String
  "If the job\/roll was queried via the machine query, this returns the value at the query timestamp.\nIf the query timestamp is 'null' and the job\/roll is active, this is the live-value.\nOtherwise (a completed job\/roll\/time-span is queried via another query), this value is 'null'."
  valueAtQueryTimestamp: Float
  "The value with the longest duration during the job\/roll\/time-span in SI unit.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null')."
  valueWithLongestDuration: Float
}

"A numeric trend element."
type NumericTrendElement {
  "The time."
  time: DateTime!
  "The numeric value."
  value: Float
}

"A numeric value that is localized to SI unit."
type NumericValue {
  "The unit of the numeric value.\n(if the unit needs to be translated, the corresponding i18n tag is provided here; for example 'label.items').\n\n\n**Returns:**\nThe unit if it exists, or null otherwise."
  unit: String
  "The numeric value in SI unit.\n\n\n**Returns:**\nThe numeric value if it exists, or null otherwise."
  value: Float
}

"The overall equipment effectiveness (OEE) and its sub-values."
type OeeValues {
  "This shows which percentage of the planned production time the machine was productive.\nThe missing percentage to 100 % are the downtime and setup losses."
  availability: Float
  "This shows which percentage of the target speed was reached during the productive time.\nThe missing percentage to 100 % is the performance\/speed loss.\nIs 'null' if there is no 'TargetSpeed'."
  effectiveness: Float
  "The overall equipment effectiveness is a measure that identifies the percentage of production time that is truly productive.\nFor the comparison of jobs, the OEE has its weaknesses as the necessary setup time (which depends on the previous job) has a huge influence.\nIt is 'Availability' * 'Effectiveness' * 'Quality'."
  oee: Float
  "This shows which percentage of the production was in acceptable quality (inverted scrap ratio).\nThe missing percentage to 100 % is the quality loss."
  quality: Float
}

"An optical density capability test specification."
type OpticalDensityCapabilityTestSpecification implements CapabilityTestSpecification {
  "Unique identifier of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestSpecificationId: String!
  "Type of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestType: CapabilityTestType!
  "Date of the creation of the capability test specification.\n[Source: CapabilityTestSpecification]"
  createdAt: DateTime!
  "Description of the capability test specification.\n[Source: CapabilityTestSpecification]"
  description: String
  "The flag which signals if the deviation values are relative.\n[Source: OpticalDensityCapabilityTestSpecification]"
  isRelative: Boolean!
  "The lower deviation limit of the measured optical density.\n[Source: OpticalDensityCapabilityTestSpecification]"
  opticalDensityDeviationLowerLimit: Float
  "The upper deviation limit of the measured optical density.\n[Source: OpticalDensityCapabilityTestSpecification]"
  opticalDensityDeviationUpperLimit: Float
  "Version of the capability test specification.\n[Source: CapabilityTestSpecification]"
  version: Int!
}

"Machine entity of machines that are other than extrusion, printing or paper sack."
type OtherMachine implements Machine {
  "Number of all alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  activeMachineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String): Long
  "All alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  activeMachineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 10): [MachineAlarm!]
  "The currently active machine alarm that was started first after the current problem occurred.\nIs null, if no alarm is active on the machine.\n[Source: AlarmDataHandler]"
  activePrimalMachineAlarm: MachineAlarm
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartment!
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeatures!
  "Status of licenses for RUBY extensions and connection modules.\n[Source: LicenseManager]"
  licenses: RubyLicenses
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamily!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: String!
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: String!
  "The job entity that is currently produced on the machine if no timestamp is provided.\nOtherwise the job entity that was active at the given timestamp."
  producedJob: ProducedJob
  "The current production status of the machine.\n[Source: MachineSnapshot]"
  productionStatus: ProductionStatus!
  "Query timestamp is not provided:\nMachines OPC-UA server time and latest snapshot time are compared and the latest one is being returned.\n            \nQuery timestamp is provided:\nQuery timestamp is being returned.\n            \n[Source: Machines OPC-UA server time, latest snapshot or query timestamp]"
  time: DateTime
}

"Machine time span entity of machines that are other than extrusion, printing or paper sack."
type OtherMachineTimeSpan implements MachineTimeSpan {
  "The start timestamp of the query.\n[Source: Query]"
  from: DateTime!
  "Number of alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  machineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String "If set, only the alarms are counted that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false): Long
  "Alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  machineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "If set, only the alarms are returned that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 100): [MachineAlarm!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Returns all shifts during the query time span.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: Settings + ProductionPeriods (for operators)]"
  shifts: [MachineShift!]
  "The end timestamp of the query.\n[Source: Query]"
  to: DateTime!
}

"Machine entity of paper sack machines."
type PaperSackMachine implements Machine {
  "Number of all alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  activeMachineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String): Long
  "All alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  activeMachineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 10): [MachineAlarm!]
  "The currently active machine alarm that was started first after the current problem occurred.\nIs null, if no alarm is active on the machine.\n[Source: AlarmDataHandler]"
  activePrimalMachineAlarm: MachineAlarm
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartment!
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeatures!
  "Status of licenses for RUBY extensions and connection modules.\n[Source: LicenseManager]"
  licenses: RubyLicenses
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamily!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: String!
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: String!
  "The job entity that is currently produced on the machine if no timestamp is provided.\nOtherwise the job entity that was active at the given timestamp."
  producedJob: ProducedJob
  "The current production status of the machine.\n[Source: MachineSnapshot]"
  productionStatus: ProductionStatus!
  "Machines production speed.\n[Source: MachineSnapshots]"
  speed: NumericSnapshotValueAndTrend!
  "Query timestamp is not provided:\nMachines OPC-UA server time and latest snapshot time are compared and the latest one is being returned.\n            \nQuery timestamp is provided:\nQuery timestamp is being returned.\n            \n[Source: Machines OPC-UA server time, latest snapshot or query timestamp]"
  time: DateTime
}

"Machine settings during a paper sack job."
type PaperSackMachineSettings {
  "Set value of the cut type of the paper sack tube, which has a high impact on the whole sack construction."
  cutType: SnapshotValuesDuringProductionOfNullableOfPaperSackCutType
  "Is true, if a inner bottom patch is pasted into valve bottom (only available on bottomer jobs)."
  hasStandUpBottomInnerPatch: SnapshotValuesDuringProductionOfNullableOfBoolean
  "Is true, if a bottom patch is pasted onto valve bottom (only available on bottomer jobs)."
  hasStandUpBottomPatch: SnapshotValuesDuringProductionOfNullableOfBoolean
  "Is true, if a inner bottom patch is pasted into valve bottom. Is 'null', on open-mouth sacks (only available on bottomer jobs)."
  hasValveBottomInnerPatch: SnapshotValuesDuringProductionOfNullableOfBoolean
  "Is true, if a bottom patch is pasted onto valve bottom. Is 'null', on open-mouth sacks (only available on bottomer jobs)."
  hasValveBottomPatch: SnapshotValuesDuringProductionOfNullableOfBoolean
  "Is true, if at least one of the valve units is used to produce a valve sack. Otherwise, it is an open-mouth sack (only available on bottomer jobs)."
  isValveSack: SnapshotValuesDuringProductionOfNullableOfBoolean
  "Set value of the sack length (only available on bottomer jobs)."
  sackLength: NumericSnapshotValuesDuringProduction
  "Set value of the sack (and tube) width (only available on bottomer jobs)."
  sackWidth: NumericSnapshotValuesDuringProduction
  "Set value of the bottom width on stand-up bottom side (only available on bottomer jobs)."
  standUpBottomWidth: NumericSnapshotValuesDuringProduction
  "Set value of the tube length (only available on tuber jobs)."
  tubeLength: NumericSnapshotValuesDuringProduction
  "Set value of the tube width (only available on tuber jobs)."
  tubeWidth: NumericSnapshotValuesDuringProduction
  "Set value of the bottom width on valve bottom side (only available on bottomer jobs)."
  valveBottomWidth: NumericSnapshotValuesDuringProduction
  "Number of valve layers (only available on bottomer jobs)."
  valveLayers: SnapshotValuesDuringProductionOfNullableOfInt32
}

"Machine time span entity of paper sack machines."
type PaperSackMachineTimeSpan implements MachineTimeSpan {
  "The start timestamp of the query.\n[Source: Query]"
  from: DateTime!
  "Count of produced items in acceptable quality within this time span.\n[Source: MachineSnapshots]"
  goodQuantity: SummedSnapshotValue
  "Number of alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  machineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String "If set, only the alarms are counted that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false): Long
  "Alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  machineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "If set, only the alarms are returned that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 100): [MachineAlarm!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Count of produced items in not-acceptable quality (= scrap\/waste) within this time span during production.\n[Source: MachineSnapshots]"
  scrapQuantityDuringProduction: SummedSnapshotValue
  "Count of produced items in not-acceptable quality (= scrap\/waste) within this time span during setup.\n[Source: MachineSnapshots]"
  scrapQuantityDuringSetup: SummedSnapshotValue
  "Returns all shifts during the query time span.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: Settings + ProductionPeriods (for operators)]"
  shifts: [MachineShift!]
  "Machines production speed during the time span.\n[Source: MachineSnapshots]"
  speed: NumericSnapshotValuesDuringProduction!
  "Speed level during this time span, which is determined for the speed histogram and target speed recommendation.\nOther than the normal 'Speed' property, similar speeds are grouped into categories (rounded to tens).\nAlso, job-specific downtimes are still accounted for in the speed level as they affect productivity.\nCertain situations, like roll changes or the speed-up, are excluded to maintain an accurate picture.\n[Source: MachineSnapshot]"
  speedLevel: NumericSnapshotValuesDuringProduction!
  "The end timestamp of the query.\n[Source: Query]"
  to: DateTime!
}

"Produced job entity of paper sack machines."
type PaperSackProducedJob implements ProducedJob {
  "Average machine speed during all time-ranges the machine was in status production within this job.\n[Source: KpiDataHandler]"
  averageSpeedDuringProduction: NumericValue!
  "Customer for which this job is produced.\n[Source: MachineSnapshots]"
  customer: SnapshotValuesDuringProductionOfString!
  "End timestamp of production in UTC (machine time) | This is 'null' if the job is active.\n[Source: ProductionPeriods]"
  endTime: DateTime
  "Count of produced items in acceptable quality within this job.\nThis value can be corrected by a following machine (like Arcomat) or via RUBY Track.\n[Source: KPIs]"
  goodQuantity: NumericValue!
  "True, if the job is currently active.\n[Source: ProductionPeriods]"
  isActive: Boolean!
  "Is true, if 'OriginalGoodQuantity' is smaller than 'GoodQuantity'.\nThis indicates an irregularity during production (like re-palletizing via control station).\n[Source: KPIs]"
  isApparentlyWrongGoodQuantity: Boolean!
  "Id of produced job (unique for the machine)\n(The id of the produced job might be equal to the productionRequestId, but some machines add a suffix,\nfor example most printing presses behave like this: productionRequestId='JobA' =&gt; jobId='JobA-0023').\n[Source: ProductionPeriods]"
  jobId: String!
  "Target quantity to produce with this job.\n[Source: MachineSnapshots]"
  jobSize: NumericSnapshotValuesDuringProduction!
  "Unique identifier of the machine this job is produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: ProductionPeriods]"
  machineId: String!
  "Machine settings during this job.\n[Source: MachineSnapshot]"
  machineSettings: PaperSackMachineSettings!
  "Free text that can be used to describe product specs (like valve type), material or other information\n(third tab on PROCONTROL product administration page).\n[Source: MachineSnapshot]"
  materialInformation: SnapshotValuesDuringProductionOfString!
  "Free text that can be used to describe product specs (like valve type), material or other information\n(first tab on PROCONTROL product administration page).\n[Source: MachineSnapshot]"
  materialText: SnapshotValuesDuringProductionOfString!
  "The machines counter of produced items in acceptable quality within this job.\nThis is the original value of the machine, which was not corrected by a following machine (like Arcomat) or via RUBY Track.\n[Source: KPIs]"
  originalGoodQuantity: NumericValue!
  "The overall equipment effectiveness (OEE) is a measure that identifies the percentage of production time that is truly productive.\nThe OEE is calculated from three sub values (Availability, Effectiveness, Quality) which indicate how the productivity was lost.\nFor the comparison of jobs, the OEE has its weaknesses as the necessary setup time (which depends on the previous job) has a huge influence."
  overallEquipmentEffectiveness: OeeValues
  "Values that are measuring the productivity of a job (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values.\nTherefore, some values are 'null' when the related target values are not given for the job.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of jobs\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs).\n[Source: KPIs]"
  performance: ProducedPerformance
  "Product group of this job.\nIn a product group, jobs with products sharing similar attributes are grouped together for joint analysis and to specify target values for future jobs.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: KpiDataHandler]"
  productGroup: PaperSackProductGroup
  "Id of the product which is produced (not the product definition).\nUsually, this is the article number.\n[Source: ProductionPeriods]"
  productId: String
  "Information about the production approval event of this job.\nThe production approval can be performed on the OperatorUI (usually by the shift supervisor).\nThis feature is only visible to the user, if it is activated in the 'Track' section of the AdminUI.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: KpiDataHandler]"
  productionApproval: ProductionApprovalEvent
  "Cumulated minutes the machine was in each production status during this job.\nAlso, the total times are provided.\n[Source: KPIs]"
  productionTimes: ProductionTimes
  "Time which the remaining production of this job is estimated to take (is 'null' for completed jobs).\nCalculated based on average machine speed during production and remaining quantity to produce.\n[Source: KPIs]"
  remainingProductionTimeInMin: Float
  "Count of produced items in not-acceptable quality (= scrap\/waste) within this job.\nThis value can be corrected by a following machine (like Arcomat) or via RUBY Track.\nThis includes 'SetupScrapQuantity'.\n[Source: KPIs]"
  scrapQuantity: NumericValue!
  "Count of produced items in not-acceptable quality (= scrap\/waste) during setup of this job.\nThis is a sub-set of 'ScrapQuantity'.\n[Source: KPIs]"
  setupScrapQuantity: NumericValue!
  "Machines production speed during this job.\nOther than the AverageSpeedDuringProduction property these values are determined over all time-ranges of the job (including setup and downtime).\n[Source: MachineSnapshot]"
  speed: NumericSnapshotValuesDuringProduction!
  "Speed level during this job, which is determined for the speed histogram and target speed recommendation.\nOther than the normal 'Speed' property, similar speeds are grouped into categories (rounded to tens).\nAlso, job-specific downtimes are still accounted for in the speed level as they affect productivity.\nCertain situations, like roll changes or ramp-ups, are excluded to maintain an accurate picture.\n[Source: MachineSnapshot]"
  speedLevel: NumericSnapshotValuesDuringProduction!
  "Start timestamp of production in UTC (machine time).\n[Source: ProductionPeriods]"
  startTime: DateTime!
  "The overall time the production of this job should take,\nwhich includes setup time, job-related downtimes and scrap losses.\nThis is the job size divided by the target value of the total good production rate,\nwhich is calculated by the target values for speed, scrap, downtime and setup.\nThis value is 'null', if there is no target value for speed, scrap or downtime.\nIf there is no expected setup time for this job, the actual setup time is taken.\n[Source: KPIs]"
  targetJobTimeInMin: Float
  "The target machine speed of this job, which is usually defined by the production planning department.\nThe origin of the value can be different (priority is 1 to 5):\n1.) Job-specific value defined\/corrected in RUBY (via OperatorUI or Track)\n2.) Product(group)-specific setting (via Track)\n3.) Job-specific value defined in customer system (via Connect 4 Flow)\n4.) Value entered in ProControl (ProcessData)\n5.) Default setting (via Track section in Admin)\n[Source: KpiDataHandler]"
  targetSpeed: NumericValue
  "All time ranges in which this job was produced\n(excludes job breaks like weekends;\non active jobs the 'to' is the machine time at query moment).\n[Source: ProductionPeriods]"
  timeRanges: [TimeRange!]
  "Condensed production history of this job, like it is displayed in RUBY Track Operator UI.\nThis list contains all history entries in ascending order (-&gt; usually first entry is 'Setup').\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: ProductionPeriods via Track.Common]"
  trackProductionHistory: [TrackHistoryEntry!]
  "Unique produced job identifier (in format MachineId_Job, like: \"EQ12345_JobA-1234\").\nThe machineId needs to be added, because it is possible that a job with the same name is produced on different machines.\n[Source: FrameworkAPI]"
  uniqueId: String!
  "Unique produced job identifier (in format MachineId_Job, like: \"EQ12345_JobA-1234\") of the related tuber\/bottomer job.\nThe two main steps of paper sack production (tube and bottom forming) are executed on different machines (tuber and bottomer) in a production line.\nThese two main machines are connected separately to RUBY and therefore there are two separate jobs for the production of one paper sack order.\nFor many reasons it is interesting how the job was produced on the other machine and so this relation can be made with this value.\nIf this entity is a produced job of a bottomer, this value is the unique id of the related produced job on the tuber.\nIf this entity is a produced job of a tuber, this value is the unique id of the related produced job on the bottomer.\nThe relation between these jobs is only done by the naming of the produced jobs or the products.\nIf there is no similar named job or product in the last three days, this value is 'null'.\n[Source: KPIs]"
  uniqueIdOfRelatedProducedJobFromOtherMachine: String
}

"Product group entity of paper sack machines.\nIn a product group, jobs with products sharing similar attributes are grouped together for joint analysis and to specify target values for future jobs.\nWhile individual products may have different dimensions and manufactured for different customers, their performance should be very similar.\nProducts are categorized into different product groups when they differ in one of the 'Attributes'."
type PaperSackProductGroup {
  "Values of all attributes that define this product group.\nThe attributes are defined in the product group definition.\nThis also contains legacy attributes of old product group definition versions (these are marked in the description).\nAll jobs of this product group have the same attributes.\nThese attributes were selected by WuH because they can be derived from machine data\nand have significant impact on the production performance.\n[Source: KpiDataHandler]"
  attributes: PaperSackProductGroupAttributes!
  "The start time of the first job that produced a product of this product group.\n[Source: KpiDataHandler]"
  firstProductionDate: DateTime!
  "A well readable name for this product group.\nAs the 'Id' is not really human readable, the product groups initially get a number as 'FriendlyName'.\nThe customer is able to change this 'FriendlyName'.\nAfter a change of the 'ProductGroupDefinitionVersion',\nthe 'FriendlyName' of the parent product group is taken (and suffixed if a parent has multiple children).\n[Source: KpiDataHandler]"
  friendlyName: String!
  "Unique identifier of the product group.\nThis 'Id' is assembled from the 'ProductGroupDefinitionVersion'\nand the 'Attributes' (in a specific way that is define din the product group definition).\n[Source: KpiDataHandler]"
  id: String!
  "The end time of the last job that produced a product of this product group.\nIf the production is currently active, this is should nearly be the machine time.\n[Source: KpiDataHandler]"
  lastProductionDate: DateTime!
  "Machine-specific notes with information\/comments\/instructions for the product group.\nThis dictionary contains one item for all machines that have an machine-specific note for this product group\n(-&gt; is the machine is not in this dictionary, there is no note, yet).\n[Source: KpiDataHandler]\nDictionary (key: machineId; value: machine-specific note)"
  notePerMachine: [KeyValuePairOfStringAndString!]!
  "Note with information\/comments\/instructions for the whole product group (independent from the machine).\nIs 'null', if there is no overall note, yet.\n[Source: KpiDataHandler]"
  overallNote: String
  "Unique identifier of the product group in which most of the jobs of this product group have been in the last version.\nWhen the 'ProductGroupDefinitionVersion' is raised, the product groups of all jobs are re-determined.\nIn that phase, all new product groups would not have user-defined properties (like friendly name, target speed or notes).\nAs these user-defined properties should not get lost, these are taken from the parent product group.\nThe parent product group is determined like this:\n- For all jobs of the new product group, the product group of the previous version is queried.\n- As this might return a list of product groups, the one with the most produced quantity is taken.\n[Source: KpiDataHandler]"
  parentId: String
  "Number of jobs from all machines that produced a product of this product group.\nAttention: This value can be incorrect if the id\/times of a job were corrected afterwards.\n[Source: KpiDataHandler]"
  producedJobsCount: Int!
  "A version that is count-up if the product group definition changes\n(for example when a new attribute should be considered).\nThis version is the prefix of the 'Id'.\n[Source: KpiDataHandler]"
  productGroupDefinitionVersion: Int!
  "Names of all products that are belonging to this product group.\nAttention: This list can contain incorrect items if the product of a job was corrected afterwards.\n[Source: KpiDataHandler]"
  productIds: [String!]!
  "Statistics (produced jobs and aggregated KPIs) of this product group per machine.\nThis dictionary contains one item for all machines that have jobs that fit to the filters\n(-&gt; is the machine is not in this dictionary, there is no fitting job on this machine).\nThe list is sorted by 'TotalProducedGoodQuantity' (the machine with the highest value is the first item).\nThe cancellation token.\nInternal productGroupStandardKpi data loader.\nInternal machineMetaData data loader.\nInternal service.\nOnly jobs that were produced after this timestamp are considered.\nOnly jobs that were produced before this timestamp are considered. If this is 'null', all jobs until now are considered.\nOnly jobs with this product are considered.\nOnly jobs from this machine are considered.\nOnly jobs from this machine family are considered.\nDictionary (key: machineId; value: statistics)"
  statisticsPerMachine(from: DateTime! machineFamilyFilter: PaperSackMachineFamilyFilter! = BOTH machineIdFilter: String productIdFilter: String to: DateTime): [KeyValuePairOfStringAndPaperSackProductGroupStatisticsPerMachine!]
  "Machine-specific target speed settings for the product group.\nThis dictionary contains one item for all machines that have an target speed setting for this product group\n(-&gt; is the machine is not in this dictionary, there is no target speed setting, yet).\n[Source: KpiDataHandler]\nDictionary (key: machineId; value: target speed)"
  targetSpeedSettingPerMachine: [KeyValuePairOfStringAndNumericValue!]!
}

"Values of all attributes that define a product group.\nThis also contains legacy attributes of old product group definition versions (these are marked in the description).\nAll jobs of a product group have the same attributes.\nThese attributes were selected by WuH because they can be derived from machine data\nand have significant impact on the production performance."
type PaperSackProductGroupAttributes {
  "Set value for stand-up bottom width.\nSimilar values are aggregated in buckets (bucket size: 10 mm).\n[Source: Bottomer Snapshot]"
  bottomWidth: ProductGroupBucketAttributeValue!
  "Is true, if the material of one of the embedded layers is probably film or thin paper.\nIt is assumed that this is true, when one of the unwinders (that is not the inner layer) is active\nand a low web tension (smaller or equal 50 N) is used.\n[Source: Tuber Snapshot]"
  hasEmbeddedFilmOrThinPaperLayer: Boolean
  "Is true, if the material of the inner layer is probably film or thin paper.\nIt is assumed that this is true, when the highest active unwinder uses a low web tension (smaller or equal 50 N).\n[Source: Tuber Snapshot]"
  hasFilmTubeAsInnerLayer: Boolean
  "Is true, if a bottom patch is pasted onto stand-up bottom (cover patch).\nIs 'null', on open-mouth sacks or if the machine has no bottom patch unit.\n[Source: Bottomer Snapshot]"
  hasStandUpBottomCoverPatch: Boolean
  "Is true, if a inner bottom patch is pasted into stand-up bottom.\nIs 'null', on open-mouth sacks or if the machine has no inner bottom patch unit.\n[Source: Bottomer Snapshot]"
  hasStandUpBottomInnerPatch: Boolean
  "Is true, if a bottom patch is pasted onto valve bottom (cover patch).\nIs 'null', on open-mouth sacks or if the machine has no bottom patch unit.\n[Source: Bottomer Snapshot]"
  hasValveBottomCoverPatch: Boolean
  "Is true, if a inner bottom patch is pasted into valve bottom.\nIs 'null', on open-mouth sacks or if the machine has no inner bottom patch unit.\n[Source: Bottomer Snapshot]"
  hasValveBottomInnerPatch: Boolean
  "Is true, if an active valve unit has 0 as foldover length.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  hasValveNoFoldover: Boolean
  "Is true, if the paper thickness measurement of the 1st unwinder is valid and the thickness is below 75 mm.\n[Source: Tuber Snapshot]"
  is70mmPaperOnOuterLayer: Boolean
  "Is true, if the tube has a flush cut (with or without slit-cuts).\nIs false, if the tube has stepped-end cut.\n[Source: Tuber Snapshot]"
  isFlushCut: Boolean
  "Is true, if an active valve unit produces with valve type 'Tube' (2).\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isInUnitCreatedTubeValve: Boolean
  "Is true, if the valve is pasted in front of the sack (in transport direction).\nThis is calculated by checking if one of the valve positions is greater then the sack width.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isLayUpPositionOnLeadingEdge: Boolean
  "Is true, if it is an offset valve.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isOffsetValve: Boolean
  "Is true, if a second slitting tool (knife) can be used to cut the endless tube into single tubes.\nOn small tubes (approx. segment length smaller 780 mm) it is possible to use a second knife\nand therefore the machine can run faster than on large tubes (where only one knife can be used).\n[Source: Tuber Snapshot]"
  isSecondSlittingToolPossible: Boolean
  "Is true, if both valve units are active.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isSecondValveUnitNeeded: Boolean
  "Is true, if a very thick paper (&gt; 150 mm) is used in one of the cover patch units.\nIs 'null', when no residual roll length measurement is valid.\n[Source: Bottomer Snapshot]"
  isThickCoverPatchPaper: Boolean
  "Is true, if an active valve unit uses the slitting unit for PE film.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isValveFilmSlittingUnitNeeded: Boolean
  "Is true, if an active valve unit pastes a patch outside the center of the bottom square (+ 5 mm tolerance).\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  isValveOutsideOfBottomSquareCenter: Boolean
  "Is true, if at least one of the valve units is used to produce a valve sack.\nOtherwise, it is an open-mouth sack\n[Source: Bottomer Snapshot]"
  isValveSack: Boolean
  "Set value for sack width from product data.\nSimilar values are aggregated in buckets.\nThe bucket size varies (170-325 =&gt; 20 mm; 325-475 =&gt; 50 mm; 475-790 =&gt; 20 mm).\n[Source: Bottomer Snapshot]"
  sackWidth: ProductGroupBucketAttributeValue!
  "Number of paper\/film layers in the tube (max. 6), which is derived from the number of active unwinds.\n[Source: Tuber Snapshot]"
  tubeLayers: Int
  "Number of valve layers.\nIs 'null', if it is an open-mouth sack.\n[Source: Bottomer Snapshot]"
  valveLayers: Int
}

"Statistics (produced jobs and aggregated KPIs) of one product group on one machine.\nThe produced jobs might be filtered by time and\/or by product."
type PaperSackProductGroupStatisticsPerMachine {
  "The job with the highest total productivity won percentage\nof all produced jobs of this machine that are belonging to the product group and fit to the filters."
  bestJob: PaperSackProducedJob
  "Identifier of the machine for which these product group statistics were calculated."
  machineId: String!
  "Values that are measuring the productivity of a product group (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values of all jobs that fit to the filters.\nThe 'ActualValue' and 'TargetValue' are the average values per job.\nTherefore, some values are 'null' when the related target values are not given for a job.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this product group.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of product groups\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs).\n[Source: KPIs]"
  performance: ProducedPerformance!
  "All produced jobs of this machine that are belonging to the product group and fit to the filters."
  producedJobs: [PaperSackProducedJob!]!
  "Cumulated minutes the machine was in each production status during the average job that fits to the filters.\nProduct groups always have 0 minutes as 'NotQueryRelatedTimeInMin' (-&gt; 'TotalPlannedProductionTimeInMin' = 'TotalTimeInMin').\n[Source: KPIs]"
  productionTimes: ProductionTimes!
  "RUBYs recommendation for the target speed of upcoming jobs with this product group.\nThis value is derived from the aggregated speed histogram of all jobs that fit to the filters.\nThis is the speed level at which the capacity utilization rate is the highest.\nIf the machine hasn't been running faster than the determined optimum for at least one hour,\nthe recommended target speed is increased by one speed level.\nLike this, the limit can be pushed and continuous optimization of the productivity is possible.\n[Source: KPIs]"
  recommendedTargetSpeed: NumericValue
  "The speed histogram values of this product group aggregated from all jobs that fit to the filters.\nThese values show how long a machine was running and how the capacity of the machine was utilized at each speed level.\nThis list contains one item for each speed level, even if the machine was not running at that level.\nThis list is sorted ascending by speed level.\nThe first item is always speed level 50 and the last item is the speed level of the maximum machine speed.\n[Source: KPIs]"
  speedHistogram: [SpeedHistogramItem!]
  "Sum of all produced items in acceptable quality within all jobs that fit to the filters."
  totalProducedGoodQuantity: Float!
}

"A segment of a collection."
type PaperSackProductGroupsCollectionSegment {
  "A flattened list of the items."
  items: [PaperSackProductGroup!]
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type ParameterInvalidError implements Error {
  message: String!
}

"A history item for a cleaning of the physical asset."
type PhysicalAssetCleanedHistoryItem implements PhysicalAssetHistoryItem {
  "Type of the cleaning operation.\n[Source: PhysicalAssetHistory]"
  cleaningOperationType: CleaningOperationType!
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "The flag which signals if the cleaning resets past volume defects.\n[Source: CleaningOperation]"
  resetVolumeDefects: Boolean!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
}

"A history item for an inventory of the physical asset.\nCreation date of the history item is used as fallback when there is no inventory date set."
type PhysicalAssetCreatedHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
}

"A history item for a delivery of the physical asset."
type PhysicalAssetDeliveredHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
}

"A history item for a detected high volume of the physical asset."
type PhysicalAssetHighVolumeDefect implements PhysicalAssetDefect {
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "Lower limit value the measured volume is not allowed to be below.\n[Source: PhysicalAssetHistory]"
  lowerLimitValue: Float!
  "Measured value when the high volume was detected.\n[Source: PhysicalAssetDefect]"
  measuredValue: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "Set value when the high volume was detected.\n[Source: PhysicalAssetDefect]"
  setValue: Float!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetDefect]"
  unit: String!
  "Upper limit value the measured volume is not allowed to be above.\n[Source: PhysicalAssetHistory]"
  upperLimitValue: Float
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  volumeCapabilityTestSpecification: VolumeCapabilityTestSpecification!
}

"A history item for a detected high volume of the physical asset."
type PhysicalAssetHighVolumeHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "Lower limit value the measured volume is not allowed to be below.\n[Source: PhysicalAssetHistory]"
  lowerLimitValue: Float!
  "Measured value when the high volume was detected.\n[Source: PhysicalAssetHistory]"
  measuredValue: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Set value when the high volume was detected.\n[Source: PhysicalAssetHistory]"
  setValue: Float!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
  "Upper limit value the measured volume is not allowed to be above.\n[Source: PhysicalAssetHistory]"
  upperLimitValue: Float
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  volumeCapabilityTestSpecification: VolumeCapabilityTestSpecification!
}

"A history item for a detected low volume of the physical asset."
type PhysicalAssetLowVolumeDefect implements PhysicalAssetDefect {
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "Lower limit value the measured volume is not allowed to be below.\n[Source: PhysicalAssetHistory]"
  lowerLimitValue: Float!
  "Measured value when the low volume was detected.\n[Source: PhysicalAssetDefect]"
  measuredValue: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "Set value when the low volume was detected.\n[Source: PhysicalAssetDefect]"
  setValue: Float!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetDefect]"
  unit: String!
  "Upper limit value the measured volume is not allowed to be above.\n[Source: PhysicalAssetHistory]"
  upperLimitValue: Float
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  volumeCapabilityTestSpecification: VolumeCapabilityTestSpecification!
}

"A history item for a detected low volume of the physical asset."
type PhysicalAssetLowVolumeHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "Lower limit value the measured volume is not allowed to be below.\n[Source: PhysicalAssetHistory]"
  lowerLimitValue: Float!
  "Measured value when the low volume was detected.\n[Source: PhysicalAssetHistory]"
  measuredValue: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Set value when the low volume was detected.\n[Source: PhysicalAssetHistory]"
  setValue: Float!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
  "Upper limit value the measured volume is not allowed to be above.\n[Source: PhysicalAssetHistory]"
  upperLimitValue: Float
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  volumeCapabilityTestSpecification: VolumeCapabilityTestSpecification!
}

"A defect for a detected scoring line on an position of the physical asset."
type PhysicalAssetScoringLineDefect implements PhysicalAssetDefect {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "The position on the physical asset.\n[Source: PhysicalAssetDefect]"
  position: Float!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetDefect]"
  unit: String!
}

"A history item for a detected scoring line on an position of the physical asset."
type PhysicalAssetScoringLineHistoryItem implements PhysicalAssetHistoryItem {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "The position on the physical asset.\n[Source: PhysicalAssetHistory]"
  position: Float!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
}

"A history item for a scrapping of the physical asset."
type PhysicalAssetScrappedHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
}

type PhysicalAssetSettings {
  "The interval the physical asset should get cleaned.\n[Source: GlobalSettings]"
  cleaningInterval: ValueWithUnitOfInt32!
}

"A defect for a detected a surface anomaly from start to end position of the physical asset."
type PhysicalAssetSurfaceAnomalyDefect implements PhysicalAssetDefect {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "The end position on the physical asset.\n[Source: PhysicalAssetDefect]"
  endPosition: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
  "The start position on the physical asset.\n[Source: PhysicalAssetDefect]"
  startPosition: Float!
  "The unit of the set and measured value.\n[Source: PhysicalAssetDefect]"
  unit: String!
}

"A history item for a detected surface anomaly from start to end position of the physical asset."
type PhysicalAssetSurfaceAnomalyHistoryItem implements PhysicalAssetHistoryItem {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The end position on the physical asset.\n[Source: PhysicalAssetHistory]"
  endPosition: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The start position on the physical asset.\n[Source: PhysicalAssetHistory]"
  startPosition: Float!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
}

"A physical asset time usage counter."
type PhysicalAssetTimeUsageCounter {
  "Value of the counter at the start of the last cleaning.\n[Source: PhysicalAsset]"
  atLastCleaning: Long
  "Current value of the counter.\n[Source: PhysicalAsset]"
  current: Long!
  "Value of the counter since the last cleaning.\n[Source: PhysicalAsset]"
  sinceLastCleaning: Long
  "The unit of the counter values.\n[Source: PhysicalAsset]"
  unit: String!
}

type PhysicalAssetUpdateSettingsPayload {
  errors: [PhysicalAssetUpdateSettingsError!]
  updatePhysicalAssetSettings: PhysicalAssetSettings
}

"A physical asset usage counter."
type PhysicalAssetUsageCounter {
  "Value of the counter at the start of the last cleaning.\n[Source: PhysicalAsset]"
  atLastCleaning: Long
  "Value of the the interval the physical asset should get cleaned..\n[Source: PhysicalAssetSettings]"
  cleaningInterval: Long!
  "Flag if the the physical assset usage counter is greater then the cleaning interval.\n[Source: PhysicalAsset]"
  cleaningIntervalExceeded: Boolean!
  "Current value of the counter.\n[Source: PhysicalAsset]"
  current: Long!
  "Value of the counter since the last cleaning.\n[Source: PhysicalAsset]"
  sinceLastCleaning: Long
  "The unit of the counter values.\n[Source: PhysicalAsset]"
  unit: String!
}

"A history item for an volume measurement of the physical asset."
type PhysicalAssetVolumeMeasuredHistoryItem implements PhysicalAssetHistoryItem {
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "Lower limit value the measured volume is not allowed to be below.\n[Source: PhysicalAssetHistory]"
  lowerLimitValue: Float!
  "Measured value when volume was measured.\n[Source: PhysicalAssetHistory]"
  measuredValue: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Set value when the volume was measured.\n[Source: PhysicalAssetHistory]"
  setValue: Float!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
  "Upper limit value the measured volume is not allowed to be above.\n[Source: PhysicalAssetHistory]"
  upperLimitValue: Float
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  volumeCapabilityTestSpecification: VolumeCapabilityTestSpecification!
}

"A defect for a detected a volume triggered print anomaly from start to end position of the physical asset."
type PhysicalAssetVolumeTriggeredPrintAnomalyDefect implements PhysicalAssetDefect {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the defect event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetDefect]"
  createdAt: DateTime!
  "The end position on the physical asset.\n[Source: PhysicalAssetDefect]"
  endPosition: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetDefect]"
  note: String
  "Type of the physical asset defect.\n[Source: PhysicalAssetDefect]"
  physicalAssetDefectType: PhysicalAssetDefectType!
  "Generated unique id of the source resulting into the defect.\n[Source: PhysicalAssetDefect]"
  sourceId: String!
  "The start position on the physical asset.\n[Source: PhysicalAssetDefect]"
  startPosition: Float!
  "The unit of the set and measured value.\n[Source: PhysicalAssetDefect]"
  unit: String!
}

"A history item for a detected volume triggered print anomaly from start to end position of the physical asset."
type PhysicalAssetVolumeTriggeredPrintAnomalyHistoryItem implements PhysicalAssetHistoryItem {
  "The specification used to check the test result.\n[Source: PhysicalAssetHistory]"
  aniloxCapabilityTestSpecification: AniloxCapabilityTestSpecification!
  "Date on which the history event occurred (is within the lifetime of the physical asset).\n[Source: PhysicalAssetHistory]"
  createdAt: DateTime!
  "The end position on the physical asset.\n[Source: PhysicalAssetHistory]"
  endPosition: Float!
  "The additional note added by the user.\n[Source: PhysicalAssetHistory]"
  note: String
  "Type of the physical asset history item.\n[Source: PhysicalAssetHistory]"
  physicalAssetHistoryItemType: PhysicalAssetHistoryItemType!
  "Generated unique id of the source resulting into the history item.\n[Source: PhysicalAssetHistory]"
  sourceId: String!
  "The start position on the physical asset.\n[Source: PhysicalAssetHistory]"
  startPosition: Float!
  "The unit of the set and measured value.\n[Source: PhysicalAssetHistory]"
  unit: String!
}

type PhysicalAssetsCreateAniloxCapabilityTestResultPayload {
  createdAniloxCapabilityTestResult: AniloxCapabilityTestResult
  errors: [PhysicalAssetsCreateAniloxCapabilityTestResultError!]
}

type PhysicalAssetsCreateAniloxPayload {
  createdAniloxPhysicalAsset: AniloxPhysicalAsset
  errors: [PhysicalAssetsCreateAniloxError!]
}

type PhysicalAssetsCreateCleaningOperationPayload {
  createdCleaningOperationResult: CleaningOperation
  errors: [PhysicalAssetsCreateCleaningOperationError!]
}

type PhysicalAssetsCreateRefurbishingAniloxOperationPayload {
  createdRefurbishingAniloxOperationResult: RefurbishingOperation
  errors: [PhysicalAssetsCreateRefurbishingAniloxOperationError!]
}

type PhysicalAssetsCreateScrappingOperationPayload {
  createdScrappingOperationResult: ScrappingOperation
  errors: [PhysicalAssetsCreateScrappingOperationError!]
}

type PhysicalAssetsCreateVolumeCapabilityTestResultPayload {
  createdVolumeCapabilityTestResult: VolumeCapabilityTestResult
  errors: [PhysicalAssetsCreateVolumeCapabilityTestResultError!]
}

type PhysicalAssetsUpdateAniloxPayload {
  errors: [PhysicalAssetsUpdateAniloxError!]
  updatedAniloxPhysicalAsset: AniloxPhysicalAsset
}

"A plate physical asset."
type PlatePhysicalAsset implements PhysicalAsset {
  "Date of the creation of the physical asset.\n[Source: PhysicalAsset]"
  createdAt: DateTime!
  "The defects of the physical asset.\n[Source: PhysicalAsset]"
  defects: [PhysicalAssetDefect!]
  "Date of the delivery of the physical asset.\n[Source: PhysicalAsset]"
  deliveredAt: DateTime
  "Description of the physical asset.\n[Source: PhysicalAsset]"
  description: String
  "Equipment the physical asset is currently equipped by e.g. machine.\n[Source: PhysicalAsset]"
  equippedBy: Equipment
  "The history of the physical asset.\n[Source: PhysicalAsset]"
  history: [PhysicalAssetHistoryItem!]
  "Initial time usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialTimeUsageCounter: Long
  "Initial usage counter of the physical asset (if already tracked before by other systems).\n[Source: PhysicalAsset]"
  initialUsageCounter: Long
  "Date of the last change to the metadata, tests or operations of the physical asset.\n[Source: PhysicalAsset]"
  lastChange: DateTime!
  "Last type of cleaning when the physical asset was last cleaned.\n[Source: PhysicalAsset]"
  lastCleaning: TrackedValueOfCleaningOperationType
  "Last consumed material when the physical asset was last used e.g. color.\n[Source: PhysicalAsset]"
  lastConsumedMaterial: TrackedValueOfString
  "Manufacturer of the physical asset.\n[Source: PhysicalAsset]"
  manufacturer: String
  "Unique identifier of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetId: String!
  "Type of the physical asset.\n[Source: PhysicalAsset]"
  physicalAssetType: PhysicalAssetType!
  "Preferred usage location (like: \"EQ12345\" or \"MIRAFLEX AM Dualport\") of the physical asset.\n[Source: PhysicalAsset]"
  preferredUsageLocation: String
  "List of unique scan codes (e.g. QR codes) identifying the physical asset.\n[Source: PhysicalAsset]"
  scanCodes: [String!]!
  "Serial number of the physical asset.\n[Source: PhysicalAsset]"
  serialNumber: String!
  "Surface of the plate physical asset.\n[Source: PlatePhysicalAsset]"
  surface: [PlateSurfacePoint!]
  "Tracked time for which the physical asset was used.\n[Source: PhysicalAsset]"
  timeUsageCounter: PhysicalAssetTimeUsageCounter!
  "Tracked output that the physical asset has produced.\n[Source: PhysicalAsset]"
  usageCounter: PhysicalAssetUsageCounter!
}

"A point on the surface of the plate physical asset."
type PlateSurfacePoint {
  "Measured value of a point on the surface of the plate physical asset.\n[Source: PlatePhysicalAsset]"
  value: Float!
  "X coordinate of a point on the surface of the plate physical asset.\n[Source: PlatePhysicalAsset]"
  x: Int!
  "Y coordinate of a point on the surface of the plate physical asset.\n[Source: PlatePhysicalAsset]"
  y: Int!
}

"Values measured by sensors, quality measurements, actual Values of machine settings, Values calculated by PLC, ..."
type PrintingActualProcessValues {
  "Indicates if the inspection system BARCODE-CHECK was active\n[Source: MachineSnapshot]"
  barcodeCheckIsActive: SnapshotValueOfBoolean!
  "Value of the blower speed of the in between color deck drying (only flexo print)"
  betweenDeckDryingBlowerSpeed: NumericSnapshotValue!
  "Value of the temperature of the in between color deck drying (only flexo print)"
  betweenDeckDryingTemperature: NumericSnapshotValue!
  "Value of the viscosity in color deck 10 (only flexo print)"
  colorDeck10Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 11 (only flexo print)"
  colorDeck11Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 12 (only flexo print)"
  colorDeck12Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 1 (only flexo print)"
  colorDeck1Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 2 (only flexo print)"
  colorDeck2Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 3 (only flexo print)"
  colorDeck3Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 4 (only flexo print)"
  colorDeck4Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 5 (only flexo print)"
  colorDeck5Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 6 (only flexo print)"
  colorDeck6Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 7 (only flexo print)"
  colorDeck7Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 8 (only flexo print)"
  colorDeck8Viscosity: NumericSnapshotValue!
  "Value of the viscosity in color deck 9 (only flexo print)"
  colorDeck9Viscosity: NumericSnapshotValue!
  "Indicates if the inspection system DEFECT-CHECK was active\n[Source: MachineSnapshot]"
  defectCheckIsActive: SnapshotValueOfBoolean!
  "The web tension value of draw #10 of the printing press\n[Source: MachineSnapshot]"
  draw10WebTension: NumericSnapshotValue!
  "The web tension value of draw #11 of the printing press\n[Source: MachineSnapshot]"
  draw11WebTension: NumericSnapshotValue!
  "The web tension value of draw #12 of the printing press\n[Source: MachineSnapshot]"
  draw12WebTension: NumericSnapshotValue!
  "The web tension value of draw #1 of the printing press\n[Source: MachineSnapshot]"
  draw1WebTension: NumericSnapshotValue!
  "The web tension value of draw #2 of the printing press\n[Source: MachineSnapshot]"
  draw2WebTension: NumericSnapshotValue!
  "The web tension value of draw #3 of the printing press\n[Source: MachineSnapshot]"
  draw3WebTension: NumericSnapshotValue!
  "The web tension value of draw #4 of the printing press\n[Source: MachineSnapshot]"
  draw4WebTension: NumericSnapshotValue!
  "The web tension value of draw #5 of the printing press\n[Source: MachineSnapshot]"
  draw5WebTension: NumericSnapshotValue!
  "The web tension value of draw #6 of the printing press\n[Source: MachineSnapshot]"
  draw6WebTension: NumericSnapshotValue!
  "The web tension value of draw #7 of the printing press\n[Source: MachineSnapshot]"
  draw7WebTension: NumericSnapshotValue!
  "The web tension value of draw #8 of the printing press\n[Source: MachineSnapshot]"
  draw8WebTension: NumericSnapshotValue!
  "The web tension value of draw #9 of the printing press\n[Source: MachineSnapshot]"
  draw9WebTension: NumericSnapshotValue!
  "The actual process values for gravure print unit 1."
  gravurePrintUnit1: PrintingGravurePrintUnit1!
  "The actual process values for gravure print unit 10."
  gravurePrintUnit10: PrintingGravurePrintUnit10!
  "The actual process values for gravure print unit 11."
  gravurePrintUnit11: PrintingGravurePrintUnit11!
  "The actual process values for gravure print unit 12."
  gravurePrintUnit12: PrintingGravurePrintUnit12!
  "The actual process values for gravure print unit 13."
  gravurePrintUnit13: PrintingGravurePrintUnit13!
  "The actual process values for gravure print unit 14."
  gravurePrintUnit14: PrintingGravurePrintUnit14!
  "The actual process values for gravure print unit 2."
  gravurePrintUnit2: PrintingGravurePrintUnit2!
  "The actual process values for gravure print unit 3."
  gravurePrintUnit3: PrintingGravurePrintUnit3!
  "The actual process values for gravure print unit 4."
  gravurePrintUnit4: PrintingGravurePrintUnit4!
  "The actual process values for gravure print unit 5."
  gravurePrintUnit5: PrintingGravurePrintUnit5!
  "The actual process values for gravure print unit 6."
  gravurePrintUnit6: PrintingGravurePrintUnit6!
  "The actual process values for gravure print unit 7."
  gravurePrintUnit7: PrintingGravurePrintUnit7!
  "The actual process values for gravure print unit 8."
  gravurePrintUnit8: PrintingGravurePrintUnit8!
  "The actual process values for gravure print unit 9."
  gravurePrintUnit9: PrintingGravurePrintUnit9!
  "Indicates if the inspection system RGBLAB-CHECK was active\n[Source: MachineSnapshot]"
  rgbLabCheckIsActive: SnapshotValueOfBoolean!
  "The status of treater 1 of the printing press\n[Source: MachineSnapshot]"
  treater1IsActive: SnapshotValueOfBoolean!
  "The actual treatment value of treater 1 of the printing press\n[Source: MachineSnapshot]"
  treater1Treatment: NumericSnapshotValue!
  "The status of treater 2 of the printing press\n[Source: MachineSnapshot]"
  treater2IsActive: SnapshotValueOfBoolean!
  "The actual treatment value of treater 2 of the printing press\n[Source: MachineSnapshot]"
  treater2Treatment: NumericSnapshotValue!
  "Value of the blower speed of the tunnel drying (only flexo print)"
  tunnelDryingBlowerSpeed: NumericSnapshotValue!
  "Value of the temperature of the tunnel drying (only flexo print)"
  tunnelDryingTemperature: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 1."
type PrintingGravurePrintUnit1 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 10."
type PrintingGravurePrintUnit10 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 11."
type PrintingGravurePrintUnit11 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 12."
type PrintingGravurePrintUnit12 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 13."
type PrintingGravurePrintUnit13 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 13."
type PrintingGravurePrintUnit14 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit2."
type PrintingGravurePrintUnit2 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 3."
type PrintingGravurePrintUnit3 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 4."
type PrintingGravurePrintUnit4 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 5."
type PrintingGravurePrintUnit5 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 6."
type PrintingGravurePrintUnit6 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 7."
type PrintingGravurePrintUnit7 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 8."
type PrintingGravurePrintUnit8 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"All process parameters related to one gravure printing unit 9."
type PrintingGravurePrintUnit9 {
  "Drying zone 1 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying1Temperature: NumericSnapshotValue!
  "Drying zone 2 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying2Temperature: NumericSnapshotValue!
  "Drying zone 3 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying3Temperature: NumericSnapshotValue!
  "Drying zone 4 temperature of gravure print unit \n[Source: MachineSnapshot]"
  drying4Temperature: NumericSnapshotValue!
  "ESA charge current of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeCurrent: NumericSnapshotValue!
  "ESA charge state of gravure print unit \n[Source: MachineSnapshot]"
  esaChargeState: NumericSnapshotValue!
  "ESA discharge state of gravure print unit \n[Source: MachineSnapshot]"
  esaDischargeState: NumericSnapshotValue!
  "Measured ink viscosity of gravure print unit \n[Source: MachineSnapshot]"
  viscosity: NumericSnapshotValue!
}

"Machine entity of printing machines."
type PrintingMachine implements Machine {
  "Number of all alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  activeMachineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String): Long
  "All alarms that are currently active on the machine.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  activeMachineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 10): [MachineAlarm!]
  "The currently active machine alarm that was started first after the current problem occurred.\nIs null, if no alarm is active on the machine.\n[Source: AlarmDataHandler]"
  activePrimalMachineAlarm: MachineAlarm
  "Values measured by sensors, quality measurements, actual values of machine settings, values calculated by PLC, ...\n[Source: MachineSnapshot]"
  actualProcessValues: PrintingActualProcessValues!
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartment!
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeatures!
  "Status of licenses for RUBY extensions and connection modules.\n[Source: LicenseManager]"
  licenses: RubyLicenses
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamily!
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: String!
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: String!
  "The job entity that is currently produced on the machine if no timestamp is provided.\nOtherwise the job entity that was active at the given timestamp."
  producedJob: ProducedJob
  "The current production status of the machine.\n[Source: MachineSnapshot]"
  productionStatus: ProductionStatus!
  "Machines production speed.\n[Source: MachineSnapshots]"
  speed: NumericSnapshotValueAndTrend!
  "Query timestamp is not provided:\nMachines OPC-UA server time and latest snapshot time are compared and the latest one is being returned.\n            \nQuery timestamp is provided:\nQuery timestamp is being returned.\n            \n[Source: Machines OPC-UA server time, latest snapshot or query timestamp]"
  time: DateTime
}

"Machine settings during a printing job."
type PrintingMachineSettings {
  "Set value of the fresh air stage of the in between color deck drying (only flexo print)\n0 means \"minimal\", 1 \"medium\" and 2 \"maximum\""
  bdDryingFreshAirStage: SnapshotValuesDuringProductionOfNullableOfInt32!
  "Set value of the temperature of the in between color deck drying (only flexo print)"
  bdDryingTemperature: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 10 (only flexo print)"
  colorDeck10AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 10 (only flexo print)"
  colorDeck10DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 10 (only flexo print)"
  colorDeck10Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 10 was active\n[Source: MachineSnapshot]"
  colorDeck10IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 10 (only flexo print)"
  colorDeck10Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 11 (only flexo print)"
  colorDeck11AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 11 (only flexo print)"
  colorDeck11DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 11 (only flexo print)"
  colorDeck11Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 11 was active\n[Source: MachineSnapshot]"
  colorDeck11IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 11 (only flexo print)"
  colorDeck11Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 12 (only flexo print)"
  colorDeck12AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 12 (only flexo print)"
  colorDeck12DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 12 (only flexo print)"
  colorDeck12Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 12 was active\n[Source: MachineSnapshot]"
  colorDeck12IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 12 (only flexo print)"
  colorDeck12Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 1 (only flexo print)"
  colorDeck1AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 1 (only flexo print)"
  colorDeck1DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 1 (only flexo print)"
  colorDeck1Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 1 was active\n[Source: MachineSnapshot]"
  colorDeck1IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 1 (only flexo print)"
  colorDeck1Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 2 (only flexo print)"
  colorDeck2AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 2 (only flexo print)"
  colorDeck2DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 2 (only flexo print)"
  colorDeck2Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 2 was active\n[Source: MachineSnapshot]"
  colorDeck2IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 2 (only flexo print)"
  colorDeck2Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 3 (only flexo print)"
  colorDeck3AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 3 (only flexo print)"
  colorDeck3DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 3 (only flexo print)"
  colorDeck3Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 3 was active\n[Source: MachineSnapshot]"
  colorDeck3IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 3 (only flexo print)"
  colorDeck3Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 4 (only flexo print)"
  colorDeck4AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 4 (only flexo print)"
  colorDeck4DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 4 (only flexo print)"
  colorDeck4Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 4 was active\n[Source: MachineSnapshot]"
  colorDeck4IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 4 (only flexo print)"
  colorDeck4Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 5 (only flexo print)"
  colorDeck5AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 5 (only flexo print)"
  colorDeck5DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 5 (only flexo print)"
  colorDeck5Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 5 was active\n[Source: MachineSnapshot]"
  colorDeck5IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 5 (only flexo print)"
  colorDeck5Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 6 (only flexo print)"
  colorDeck6AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 6 (only flexo print)"
  colorDeck6DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 6 (only flexo print)"
  colorDeck6Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 6 was active\n[Source: MachineSnapshot]"
  colorDeck6IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 6 (only flexo print)"
  colorDeck6Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 7 (only flexo print)"
  colorDeck7AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 7 (only flexo print)"
  colorDeck7DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 7 (only flexo print)"
  colorDeck7Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 7 was active\n[Source: MachineSnapshot]"
  colorDeck7IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 7 (only flexo print)"
  colorDeck7Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 8 (only flexo print)"
  colorDeck8AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 8 (only flexo print)"
  colorDeck8DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 8 (only flexo print)"
  colorDeck8Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 8 was active\n[Source: MachineSnapshot]"
  colorDeck8IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 8 (only flexo print)"
  colorDeck8Viscosity: NumericSnapshotValuesDuringProduction!
  "Set value of the anilox roller name in color deck 9 (only flexo print)"
  colorDeck9AniloxRoller: NumericSnapshotValuesDuringProduction!
  "Set value of the doctor blade pressure in color deck 9 (only flexo print)"
  colorDeck9DoctorBladePressure: NumericSnapshotValuesDuringProduction!
  "Set value of the format in color deck 9 (only flexo print)"
  colorDeck9Format: NumericSnapshotValuesDuringProduction!
  "Indicates if the color deck 9 was active\n[Source: MachineSnapshot]"
  colorDeck9IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Set value of the viscosity in color deck 9 (only flexo print)"
  colorDeck9Viscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 10, drying 1\n[Source: MachineSnapshot]"
  gravureUnit10Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 10, drying 1\n[Source: MachineSnapshot]"
  gravureUnit10Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 10, drying 1\n[Source: MachineSnapshot]"
  gravureUnit10Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 10, drying 2\n[Source: MachineSnapshot]"
  gravureUnit10Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 10, drying 2\n[Source: MachineSnapshot]"
  gravureUnit10Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 10, drying 2\n[Source: MachineSnapshot]"
  gravureUnit10Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 10, drying 3\n[Source: MachineSnapshot]"
  gravureUnit10Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 10, drying 3\n[Source: MachineSnapshot]"
  gravureUnit10Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 10, drying 3\n[Source: MachineSnapshot]"
  gravureUnit10Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 10, drying 4\n[Source: MachineSnapshot]"
  gravureUnit10Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 10, drying 4\n[Source: MachineSnapshot]"
  gravureUnit10Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 10, drying 4\n[Source: MachineSnapshot]"
  gravureUnit10Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 10\n[Source: MachineSnapshot]"
  gravureUnit10FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 10 was active\n[Source: MachineSnapshot]"
  gravureUnit10IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 10\n[Source: MachineSnapshot]"
  gravureUnit10SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 10\n[Source: MachineSnapshot]"
  gravureUnit10SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 10\n[Source: MachineSnapshot]"
  gravureUnit10SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 10\n[Source: MachineSnapshot]"
  gravureUnit10SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 11, drying 1\n[Source: MachineSnapshot]"
  gravureUnit11Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 11, drying 1\n[Source: MachineSnapshot]"
  gravureUnit11Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 11, drying 1\n[Source: MachineSnapshot]"
  gravureUnit11Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 11, drying 2\n[Source: MachineSnapshot]"
  gravureUnit11Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 11, drying 2\n[Source: MachineSnapshot]"
  gravureUnit11Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 11, drying 2\n[Source: MachineSnapshot]"
  gravureUnit11Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 11, drying 3\n[Source: MachineSnapshot]"
  gravureUnit11Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 11, drying 3\n[Source: MachineSnapshot]"
  gravureUnit11Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 11, drying 3\n[Source: MachineSnapshot]"
  gravureUnit11Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 11, drying 4\n[Source: MachineSnapshot]"
  gravureUnit11Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 11, drying 4\n[Source: MachineSnapshot]"
  gravureUnit11Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 11, drying 4\n[Source: MachineSnapshot]"
  gravureUnit11Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 11\n[Source: MachineSnapshot]"
  gravureUnit11FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 11 was active\n[Source: MachineSnapshot]"
  gravureUnit11IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 11\n[Source: MachineSnapshot]"
  gravureUnit11SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 11\n[Source: MachineSnapshot]"
  gravureUnit11SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 11\n[Source: MachineSnapshot]"
  gravureUnit11SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 11\n[Source: MachineSnapshot]"
  gravureUnit11SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 12, drying 1\n[Source: MachineSnapshot]"
  gravureUnit12Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 12, drying 1\n[Source: MachineSnapshot]"
  gravureUnit12Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 12, drying 1\n[Source: MachineSnapshot]"
  gravureUnit12Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 12, drying 2\n[Source: MachineSnapshot]"
  gravureUnit12Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 12, drying 2\n[Source: MachineSnapshot]"
  gravureUnit12Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 12, drying 2\n[Source: MachineSnapshot]"
  gravureUnit12Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 12, drying 3\n[Source: MachineSnapshot]"
  gravureUnit12Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 12, drying 3\n[Source: MachineSnapshot]"
  gravureUnit12Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 12, drying 3\n[Source: MachineSnapshot]"
  gravureUnit12Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 12, drying 4\n[Source: MachineSnapshot]"
  gravureUnit12Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 12, drying 4\n[Source: MachineSnapshot]"
  gravureUnit12Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 12, drying 4\n[Source: MachineSnapshot]"
  gravureUnit12Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 12\n[Source: MachineSnapshot]"
  gravureUnit12FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 12 was active\n[Source: MachineSnapshot]"
  gravureUnit12IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 12\n[Source: MachineSnapshot]"
  gravureUnit12SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 12\n[Source: MachineSnapshot]"
  gravureUnit12SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 12\n[Source: MachineSnapshot]"
  gravureUnit12SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 12\n[Source: MachineSnapshot]"
  gravureUnit12SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 13, drying 1\n[Source: MachineSnapshot]"
  gravureUnit13Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 13, drying 1\n[Source: MachineSnapshot]"
  gravureUnit13Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 13, drying 1\n[Source: MachineSnapshot]"
  gravureUnit13Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 13, drying 2\n[Source: MachineSnapshot]"
  gravureUnit13Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 13, drying 2\n[Source: MachineSnapshot]"
  gravureUnit13Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 13, drying 2\n[Source: MachineSnapshot]"
  gravureUnit13Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 13, drying 3\n[Source: MachineSnapshot]"
  gravureUnit13Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 13, drying 3\n[Source: MachineSnapshot]"
  gravureUnit13Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 13, drying 3\n[Source: MachineSnapshot]"
  gravureUnit13Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 13, drying 4\n[Source: MachineSnapshot]"
  gravureUnit13Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 13, drying 4\n[Source: MachineSnapshot]"
  gravureUnit13Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 13, drying 4\n[Source: MachineSnapshot]"
  gravureUnit13Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 13\n[Source: MachineSnapshot]"
  gravureUnit13FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 13 was active\n[Source: MachineSnapshot]"
  gravureUnit13IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 13\n[Source: MachineSnapshot]"
  gravureUnit13SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 13\n[Source: MachineSnapshot]"
  gravureUnit13SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 13\n[Source: MachineSnapshot]"
  gravureUnit13SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 13\n[Source: MachineSnapshot]"
  gravureUnit13SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 14, drying 1\n[Source: MachineSnapshot]"
  gravureUnit14Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 14, drying 1\n[Source: MachineSnapshot]"
  gravureUnit14Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 14, drying 1\n[Source: MachineSnapshot]"
  gravureUnit14Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 14, drying 2\n[Source: MachineSnapshot]"
  gravureUnit14Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 14, drying 2\n[Source: MachineSnapshot]"
  gravureUnit14Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 14, drying 2\n[Source: MachineSnapshot]"
  gravureUnit14Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 14, drying 3\n[Source: MachineSnapshot]"
  gravureUnit14Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 14, drying 3\n[Source: MachineSnapshot]"
  gravureUnit14Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 14, drying 3\n[Source: MachineSnapshot]"
  gravureUnit14Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 14, drying 4\n[Source: MachineSnapshot]"
  gravureUnit14Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 14, drying 4\n[Source: MachineSnapshot]"
  gravureUnit14Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 14, drying 4\n[Source: MachineSnapshot]"
  gravureUnit14Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 14\n[Source: MachineSnapshot]"
  gravureUnit14FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 14 was active\n[Source: MachineSnapshot]"
  gravureUnit14IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 14\n[Source: MachineSnapshot]"
  gravureUnit14SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 14\n[Source: MachineSnapshot]"
  gravureUnit14SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 14\n[Source: MachineSnapshot]"
  gravureUnit14SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 14\n[Source: MachineSnapshot]"
  gravureUnit14SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of grauvre unit 1, drying 1\n[Source: MachineSnapshot]"
  gravureUnit1Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of grauvre unit 1, drying 1\n[Source: MachineSnapshot]"
  gravureUnit1Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of grauvre unit 1, drying 1\n[Source: MachineSnapshot]"
  gravureUnit1Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of grauvre unit 1, drying 2\n[Source: MachineSnapshot]"
  gravureUnit1Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of grauvre unit 1, drying 2\n[Source: MachineSnapshot]"
  gravureUnit1Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of grauvre unit 1, drying 2\n[Source: MachineSnapshot]"
  gravureUnit1Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of grauvre unit 1, drying 3\n[Source: MachineSnapshot]"
  gravureUnit1Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of grauvre unit 1, drying 3\n[Source: MachineSnapshot]"
  gravureUnit1Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of grauvre unit 1, drying 3\n[Source: MachineSnapshot]"
  gravureUnit1Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of grauvre unit 1, drying 4\n[Source: MachineSnapshot]"
  gravureUnit1Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of grauvre unit 1, drying 4\n[Source: MachineSnapshot]"
  gravureUnit1Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of grauvre unit 1, drying 4\n[Source: MachineSnapshot]"
  gravureUnit1Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 1\n[Source: MachineSnapshot]"
  gravureUnit1FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 1 was active\n[Source: MachineSnapshot]"
  gravureUnit1IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 1\n[Source: MachineSnapshot]"
  gravureUnit1SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 1\n[Source: MachineSnapshot]"
  gravureUnit1SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 1\n[Source: MachineSnapshot]"
  gravureUnit1SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 1\n[Source: MachineSnapshot]"
  gravureUnit1SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 2, drying 1\n[Source: MachineSnapshot]"
  gravureUnit2Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 2, drying 1\n[Source: MachineSnapshot]"
  gravureUnit2Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 2, drying 1\n[Source: MachineSnapshot]"
  gravureUnit2Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 2, drying 2\n[Source: MachineSnapshot]"
  gravureUnit2Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 2, drying 2\n[Source: MachineSnapshot]"
  gravureUnit2Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 2, drying 2\n[Source: MachineSnapshot]"
  gravureUnit2Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 2, drying 3\n[Source: MachineSnapshot]"
  gravureUnit2Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 2, drying 3\n[Source: MachineSnapshot]"
  gravureUnit2Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 2, drying 3\n[Source: MachineSnapshot]"
  gravureUnit2Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 2, drying 4\n[Source: MachineSnapshot]"
  gravureUnit2Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 2, drying 4\n[Source: MachineSnapshot]"
  gravureUnit2Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 2, drying 4\n[Source: MachineSnapshot]"
  gravureUnit2Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 2\n[Source: MachineSnapshot]"
  gravureUnit2FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 2 was active\n[Source: MachineSnapshot]"
  gravureUnit2IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 2\n[Source: MachineSnapshot]"
  gravureUnit2SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 2\n[Source: MachineSnapshot]"
  gravureUnit2SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 2\n[Source: MachineSnapshot]"
  gravureUnit2SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 2\n[Source: MachineSnapshot]"
  gravureUnit2SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure unit 3, drying 1\n[Source: MachineSnapshot]"
  gravureUnit3Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure unit 3, drying 1\n[Source: MachineSnapshot]"
  gravureUnit3Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure unit 3, drying 1\n[Source: MachineSnapshot]"
  gravureUnit3Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure unit 3, drying 2\n[Source: MachineSnapshot]"
  gravureUnit3Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure unit 3, drying 2\n[Source: MachineSnapshot]"
  gravureUnit3Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure unit 3, drying 2\n[Source: MachineSnapshot]"
  gravureUnit3Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure unit 3, drying 3\n[Source: MachineSnapshot]"
  gravureUnit3Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure unit 3, drying 3\n[Source: MachineSnapshot]"
  gravureUnit3Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure unit 3, drying 3\n[Source: MachineSnapshot]"
  gravureUnit3Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure unit 3, drying 4\n[Source: MachineSnapshot]"
  gravureUnit3Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure unit 3, drying 4\n[Source: MachineSnapshot]"
  gravureUnit3Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure unit 3, drying 4\n[Source: MachineSnapshot]"
  gravureUnit3Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 3\n[Source: MachineSnapshot]"
  gravureUnit3FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 3 was active\n[Source: MachineSnapshot]"
  gravureUnit3IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 3\n[Source: MachineSnapshot]"
  gravureUnit3SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 3\n[Source: MachineSnapshot]"
  gravureUnit3SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 3\n[Source: MachineSnapshot]"
  gravureUnit3SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 3\n[Source: MachineSnapshot]"
  gravureUnit3SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 4, drying 1\n[Source: MachineSnapshot]"
  gravureUnit4Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 4, drying 1\n[Source: MachineSnapshot]"
  gravureUnit4Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 4, drying 1\n[Source: MachineSnapshot]"
  gravureUnit4Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 4, drying 2\n[Source: MachineSnapshot]"
  gravureUnit4Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 4, drying 2\n[Source: MachineSnapshot]"
  gravureUnit4Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 4, drying 2\n[Source: MachineSnapshot]"
  gravureUnit4Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 4, drying 3\n[Source: MachineSnapshot]"
  gravureUnit4Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 4, drying 3\n[Source: MachineSnapshot]"
  gravureUnit4Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 4, drying 3\n[Source: MachineSnapshot]"
  gravureUnit4Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 4, drying 4\n[Source: MachineSnapshot]"
  gravureUnit4Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 4, drying 4\n[Source: MachineSnapshot]"
  gravureUnit4Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 4, drying 4\n[Source: MachineSnapshot]"
  gravureUnit4Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 4\n[Source: MachineSnapshot]"
  gravureUnit4FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 4 was active\n[Source: MachineSnapshot]"
  gravureUnit4IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 4\n[Source: MachineSnapshot]"
  gravureUnit4SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 4\n[Source: MachineSnapshot]"
  gravureUnit4SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 4\n[Source: MachineSnapshot]"
  gravureUnit4SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 4\n[Source: MachineSnapshot]"
  gravureUnit4SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 5, drying 1\n[Source: MachineSnapshot]"
  gravureUnit5Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 5, drying 1\n[Source: MachineSnapshot]"
  gravureUnit5Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 5, drying 1\n[Source: MachineSnapshot]"
  gravureUnit5Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 5, drying 2\n[Source: MachineSnapshot]"
  gravureUnit5Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 5, drying 2\n[Source: MachineSnapshot]"
  gravureUnit5Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 5, drying 2\n[Source: MachineSnapshot]"
  gravureUnit5Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 5, drying 3\n[Source: MachineSnapshot]"
  gravureUnit5Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 5, drying 3\n[Source: MachineSnapshot]"
  gravureUnit5Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 5, drying 3\n[Source: MachineSnapshot]"
  gravureUnit5Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 5, drying 4\n[Source: MachineSnapshot]"
  gravureUnit5Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 5, drying 4\n[Source: MachineSnapshot]"
  gravureUnit5Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 5, drying 4\n[Source: MachineSnapshot]"
  gravureUnit5Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 5\n[Source: MachineSnapshot]"
  gravureUnit5FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 5 was active\n[Source: MachineSnapshot]"
  gravureUnit5IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 5\n[Source: MachineSnapshot]"
  gravureUnit5SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 5\n[Source: MachineSnapshot]"
  gravureUnit5SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 5\n[Source: MachineSnapshot]"
  gravureUnit5SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 5\n[Source: MachineSnapshot]"
  gravureUnit5SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 6, drying 1\n[Source: MachineSnapshot]"
  gravureUnit6Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 6, drying 1\n[Source: MachineSnapshot]"
  gravureUnit6Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 6, drying 1\n[Source: MachineSnapshot]"
  gravureUnit6Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 6, drying 2\n[Source: MachineSnapshot]"
  gravureUnit6Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 6, drying 2\n[Source: MachineSnapshot]"
  gravureUnit6Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 6, drying 2\n[Source: MachineSnapshot]"
  gravureUnit6Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 6, drying 3\n[Source: MachineSnapshot]"
  gravureUnit6Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 6, drying 3\n[Source: MachineSnapshot]"
  gravureUnit6Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 6, drying 3\n[Source: MachineSnapshot]"
  gravureUnit6Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 6, drying 4\n[Source: MachineSnapshot]"
  gravureUnit6Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 6, drying 4\n[Source: MachineSnapshot]"
  gravureUnit6Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 6, drying 4\n[Source: MachineSnapshot]"
  gravureUnit6Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 6\n[Source: MachineSnapshot]"
  gravureUnit6FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 6 was active\n[Source: MachineSnapshot]"
  gravureUnit6IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 6\n[Source: MachineSnapshot]"
  gravureUnit6SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 6\n[Source: MachineSnapshot]"
  gravureUnit6SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 6\n[Source: MachineSnapshot]"
  gravureUnit6SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 6\n[Source: MachineSnapshot]"
  gravureUnit6SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 7, drying 1\n[Source: MachineSnapshot]"
  gravureUnit7Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 7, drying 1\n[Source: MachineSnapshot]"
  gravureUnit7Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 7, drying 1\n[Source: MachineSnapshot]"
  gravureUnit7Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 7, drying 2\n[Source: MachineSnapshot]"
  gravureUnit7Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 7, drying 2\n[Source: MachineSnapshot]"
  gravureUnit7Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 7, drying 2\n[Source: MachineSnapshot]"
  gravureUnit7Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 7, drying 3\n[Source: MachineSnapshot]"
  gravureUnit7Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 7, drying 3\n[Source: MachineSnapshot]"
  gravureUnit7Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 7, drying 3\n[Source: MachineSnapshot]"
  gravureUnit7Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 7, drying 4\n[Source: MachineSnapshot]"
  gravureUnit7Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 7, drying 4\n[Source: MachineSnapshot]"
  gravureUnit7Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 7, drying 4\n[Source: MachineSnapshot]"
  gravureUnit7Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 7\n[Source: MachineSnapshot]"
  gravureUnit7FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 7 was active\n[Source: MachineSnapshot]"
  gravureUnit7IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 7\n[Source: MachineSnapshot]"
  gravureUnit7SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 7\n[Source: MachineSnapshot]"
  gravureUnit7SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 7\n[Source: MachineSnapshot]"
  gravureUnit7SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 7\n[Source: MachineSnapshot]"
  gravureUnit7SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 8, drying 1\n[Source: MachineSnapshot]"
  gravureUnit8Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 8, drying 1\n[Source: MachineSnapshot]"
  gravureUnit8Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 8, drying 1\n[Source: MachineSnapshot]"
  gravureUnit8Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 8, drying 2\n[Source: MachineSnapshot]"
  gravureUnit8Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 8, drying 2\n[Source: MachineSnapshot]"
  gravureUnit8Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 8, drying 2\n[Source: MachineSnapshot]"
  gravureUnit8Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 8, drying 3\n[Source: MachineSnapshot]"
  gravureUnit8Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 8, drying 3\n[Source: MachineSnapshot]"
  gravureUnit8Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 8, drying 3\n[Source: MachineSnapshot]"
  gravureUnit8Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 8, drying 4\n[Source: MachineSnapshot]"
  gravureUnit8Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 8, drying 4\n[Source: MachineSnapshot]"
  gravureUnit8Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 8, drying 4\n[Source: MachineSnapshot]"
  gravureUnit8Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 8\n[Source: MachineSnapshot]"
  gravureUnit8FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 8 was active\n[Source: MachineSnapshot]"
  gravureUnit8IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 8\n[Source: MachineSnapshot]"
  gravureUnit8SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 8\n[Source: MachineSnapshot]"
  gravureUnit8SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 8\n[Source: MachineSnapshot]"
  gravureUnit8SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 8\n[Source: MachineSnapshot]"
  gravureUnit8SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 9, drying 1\n[Source: MachineSnapshot]"
  gravureUnit9Drying1SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 9, drying 1\n[Source: MachineSnapshot]"
  gravureUnit9Drying1SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 9, drying 1\n[Source: MachineSnapshot]"
  gravureUnit9Drying1SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 9, drying 2\n[Source: MachineSnapshot]"
  gravureUnit9Drying2SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 9, drying 2\n[Source: MachineSnapshot]"
  gravureUnit9Drying2SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 9, drying 2\n[Source: MachineSnapshot]"
  gravureUnit9Drying2SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 9, drying 3\n[Source: MachineSnapshot]"
  gravureUnit9Drying3SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 9, drying 3\n[Source: MachineSnapshot]"
  gravureUnit9Drying3SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 9, drying 3\n[Source: MachineSnapshot]"
  gravureUnit9Drying3SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "Blower speed of gravure Unit 9, drying 4\n[Source: MachineSnapshot]"
  gravureUnit9Drying4SettingsBlowerSpeed: NumericSnapshotValuesDuringProduction!
  "heater mode of gravure Unit 9, drying 4\n[Source: MachineSnapshot]"
  gravureUnit9Drying4SettingsHeaterMode: NumericSnapshotValuesDuringProduction!
  "temperature of gravure Unit 9, drying 4\n[Source: MachineSnapshot]"
  gravureUnit9Drying4SettingsTemperature: NumericSnapshotValuesDuringProduction!
  "format length of gravure unit 9\n[Source: MachineSnapshot]"
  gravureUnit9FormatLength: NumericSnapshotValuesDuringProduction!
  "Indicates if the gravure unit 9 was active\n[Source: MachineSnapshot]"
  gravureUnit9IsActive: SnapshotValuesDuringProductionOfNullableOfBoolean!
  "Doctorblade Pressure of gravure unit 9\n[Source: MachineSnapshot]"
  gravureUnit9SettingsDoctorbladePressure: NumericSnapshotValuesDuringProduction!
  "impression roller pressure ds of gravure unit 9\n[Source: MachineSnapshot]"
  gravureUnit9SettingsImpressionRollerPressureDS: NumericSnapshotValuesDuringProduction!
  "impression roller pressure os of gravure unit 9\n[Source: MachineSnapshot]"
  gravureUnit9SettingsImpressionRollerPressureOS: NumericSnapshotValuesDuringProduction!
  "Viscosity of gravure unit 9\n[Source: MachineSnapshot]"
  gravureUnit9SettingsViscosity: NumericSnapshotValuesDuringProduction!
  "Chosen id value of the machine print style mode"
  machinePrintStyleId: SnapshotValuesDuringProductionOfNullableOfInt32!
  "Set value of the production speed"
  machineSpeed: NumericSnapshotValuesDuringProduction!
  "Chosen id value of the machine web mode"
  machineWebModeId: SnapshotValuesDuringProductionOfNullableOfInt32!
  "Set value of the substrate density from the unwinder"
  materialDensity: NumericSnapshotValuesDuringProduction!
  "Set value of the substrate e module thickness from the unwinder"
  materialEModule: NumericSnapshotValuesDuringProduction!
  "Name of the substrate from the unwinder"
  materialName: SnapshotValuesDuringProductionOfString!
  "Set value of the substrate thickness from the unwinder"
  materialThickness: NumericSnapshotValuesDuringProduction!
  "Set value of the substrate width from the unwinder"
  materialWidth: NumericSnapshotValuesDuringProduction!
  "Set value of the fresh air stage of the tunnel drying (only flexo print)\n0 means \"minimal\", 1 \"medium\" and 2 \"maximum\""
  tdDryingFreshAirStage: SnapshotValuesDuringProductionOfNullableOfInt32!
  "Set value of the temperature of the tunnel drying (only flexo print)"
  tdDryingTemperature: NumericSnapshotValuesDuringProduction!
}

"Machine time span entity of printing machines."
type PrintingMachineTimeSpan implements MachineTimeSpan {
  "The start timestamp of the query.\n[Source: Query]"
  from: DateTime!
  "Meters of produced output in acceptable quality within this time span.\n[Source: MachineSnapshots]"
  goodLength: SummedSnapshotValue
  "Number of alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nNumber of machine alarms."
  machineAlarmCount("Regular expression on the alarm code field to filter the counted alarms." alarmCodeFilterRegex: String "If set, only the alarms are counted that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false): Long
  "Alarms which were active on the machine during the query time span.\n[Source: AlarmDataHandler]\n\n\n**Returns:**\nList of MachineAlarm."
  machineAlarms("Regular expression on the alarm code field to filter the returned alarms." alarmCodeFilterRegex: String "If set, only the alarms are returned that are started first after a problem occurred." onlyPrimalAlarms: Boolean! = false "Number of alarms that are skipped (can be used for pagination)" skip: Int! = 0 "If true, the returned alarms are sorted in descending order (by default the alarms are returned in ascending order)" sortDescending: Boolean! = false "Maximum number of alarms that are returned (can be used for pagination)" take: Int! = 100): [MachineAlarm!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: String!
  "Meters of produced output in not-acceptable quality (= scrap\/waste\/maculature) within this time span during production.\n[Source: MachineSnapshots]"
  scrapLengthDuringProduction: SummedSnapshotValue
  "Meters of produced output in not-acceptable quality (= scrap\/waste\/maculature) within this time span during setup.\n[Source: MachineSnapshots]"
  scrapLengthDuringSetup: SummedSnapshotValue
  "Returns all shifts during the query time span.\nUsually, the machine is operated by different operators during the day.\nThe period of time one operator is working on the machine is called 'shift'.\nBecause of performance reasons, it is not possible to subscribe to this property (-&gt; returns 'null').\n[Source: Settings + ProductionPeriods (for operators)]"
  shifts: [MachineShift!]
  "Machines production speed during the time span.\n[Source: MachineSnapshots]"
  speed: NumericSnapshotValuesDuringProduction!
  "The target speed during the time span.\nThe target speed is usually defined by the production planning department.\nThe origin of the value can be different (priority is 1-3):\n1.) Job-specific value defined in customer system (via Connect 4 Flow)\n2.) Value entered in ProControl (ProcessData)\n3.) Default setting (via Track section in Admin)\n[Source: MachineSnapshots]"
  targetSpeed: NumericSnapshotValuesDuringProduction
  "The end timestamp of the query.\n[Source: Query]"
  to: DateTime!
}

"Produced job entity of printing machines."
type PrintingProducedJob implements ProducedJob {
  "Average machine speed during all time-ranges the machine was in production within this job.\n[Source: KPIs]"
  averageSpeedDuringProduction: NumericValue!
  "Customer for which this job is produced.\n[Source: MachineSnapshots]"
  customer: SnapshotValuesDuringProductionOfString!
  "End timestamp of production in UTC (machine time) | This is 'null' if the job is active.\n[Source: ProductionPeriods]"
  endTime: DateTime
  "Meters of produced output in acceptable quality within this job.\n[Source: KPIs]"
  goodLength: NumericValue!
  "True, if the job is currently active.\n[Source: ProductionPeriods]"
  isActive: Boolean!
  "Id of produced job (unique for the machine)\n(The id of the produced job might be equal to the productionRequestId, but some machines add a suffix,\nfor example most printing presses behave like this: productionRequestId='JobA' =&gt; jobId='JobA-0023').\n[Source: ProductionPeriods]"
  jobId: String!
  "Target quantity to produce with this job.\n[Source: MachineSnapshots]"
  jobSize: NumericSnapshotValuesDuringProduction!
  "Unique identifier of the machine this job is produced on (usually WuH equipment number, like: \"EQ12345\").\n[Source: ProductionPeriods]"
  machineId: String!
  "Machine settings during this job.\n[Source: MachineSnapshot]"
  machineSettings: PrintingMachineSettings
  "The overall equipment effectiveness (OEE) is a measure that identifies the percentage of production time that is truly productive.\nThe OEE is calculated from three sub values (Availability, Effectiveness, Quality) which indicate how the productivity was lost.\nFor the comparison of jobs, the OEE has its weaknesses as the necessary setup time (which depends on the previous job) has a huge influence."
  overallEquipmentEffectiveness: OeeValues
  "Values that are measuring the productivity of a job (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values.\nTherefore, some values are 'null' when the related target values are not given for the job.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of jobs\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs).\n[Source: KPIs]"
  performance: ProducedPerformance
  "Id of the product which is produced (not the product definition).\nUsually, this is the article number.\n[Source: ProductionPeriods]"
  productId: String
  "Cumulated minutes the machine was in each production status during this job.\nAlso, the total times are provided.\n[Source: KPIs]"
  productionTimes: ProductionTimes
  "Time which the remaining production of this job is estimated to take (is 'null' for completed jobs).\nCalculated based on average machine speed during production and remaining quantity to produce.\n[Source: KPIs]"
  remainingProductionTimeInMin: Float
  "Meters of produced output in not-acceptable quality (= scrap\/waste\/maculature) within this job.\nThis includes 'SetupScrapLength'.\n[Source: KPIs]"
  scrapLength: NumericValue!
  "Meters of produced items in not-acceptable quality (= scrap\/waste) during setup of this job.\nThis is a sub-set of 'ScrapLength'.\n[Source: KPIs]"
  setupScrapLength: NumericValue!
  "Start timestamp of production in UTC (machine time).\n[Source: ProductionPeriods]"
  startTime: DateTime!
  "The overall time the production of this job should take,\nwhich includes setup time, job-related downtimes and scrap losses.\nThis is the job size divided by the target value of the total good production rate,\nwhich is calculated by the target values for speed, scrap, downtime and setup.\nThis value is 'null', if there is no target value for speed, scrap or downtime.\nIf there is no expected setup time for this job, the actual setup time is taken.\n[Source: KPIs]"
  targetJobTimeInMin: Float
  "The target machine speed of this job, which is usually defined by the production planning department.\nThe origin of the value can be different (priority is 1-3):\n1.) Job-specific value defined in customer system (via Connect 4 Flow)\n2.) Value entered in ProControl (ProcessData)\n3.) Default setting (via Track section in Admin)\n[Source: KPIs]"
  targetSpeed: NumericValue!
  "All time ranges in which this job was produced\n(excludes job breaks like weekends;\non active jobs the 'to' is the machine time at query moment).\n[Source: ProductionPeriods]"
  timeRanges: [TimeRange!]
  "Unique produced job identifier (in format MachineId_Job, like: \"EQ12345_JobA-1234\").\nThe machineId needs to be added, because it is possible that a job with the same name is produced on different machines.\n[Source: FrameworkAPI]"
  uniqueId: String!
}

type ProducedJobChangeMachineTargetDownTimeInMinPayload {
  changedProducedJob: ProducedJob
  errors: [ProducedJobChangeMachineTargetDownTimeInMinError!]
}

type ProducedJobChangeMachineTargetScrapCountDuringProductionPayload {
  changedProducedJob: ProducedJob
  errors: [ProducedJobChangeMachineTargetScrapCountDuringProductionError!]
}

type ProducedJobChangeMachineTargetSetupTimeInMinPayload {
  changedProducedJob: ProducedJob
  errors: [ProducedJobChangeMachineTargetSetupTimeInMinError!]
}

type ProducedJobChangeMachineTargetSpeedPayload {
  changedProducedJob: ProducedJob
  errors: [ProducedJobChangeMachineTargetSpeedError!]
}

"A segment of a collection."
type ProducedJobsCollectionSegment {
  "A flattened list of the items."
  items: [ProducedJob!]
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

"Values that are measuring the productivity of a job \/ product group (-&gt; RUBYs alternative for OEE).\nThese values are calculated by comparing actual values to target\/expected values.\nTherefore, some values are 'null' when the related target values are not given for the job \/ product group.\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job \/ product group.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'Total.WonProductivity' percentage allows comparison of jobs \/ product groups\nthat not depends on the different setup efforts (which are highly dependant on the previous jobs)."
type ProducedPerformance {
  "Values to measure the downtime performance of this job \/ product group.\nThis compares the job-related downtime with the target downtime ratio."
  downtime: ProducedPerformanceValue!
  "Values to measure the scrap performance of this job \/ product group.\nThis compares the scrap during production with the target scrap ratio."
  scrap: ProducedPerformanceValue!
  "Values to measure the setup performance of this job \/ product group.\nThis compares the actual setup time with the expected setup time.\nIf the expected setup time is not given for this job \/ product group, the actual setup time is taken to calculate the total value.\nLike this, the other values stay meaningful even if the expected setup time is not set (currently only possible via Connect4Flow)."
  setup: ProducedPerformanceValue!
  "Values to measure the speed performance of this job \/ product group.\nThis compares the average speed during production with the target speed.\nThese values are only meaningful, if the target speed is set properly."
  speed: ProducedPerformanceValue!
  "Values to measure the overall performance of this job \/ product group.\nThis compared the actual overall good production rate (which is derived by average speed, setup time, job-related downtimes and scrap counts)\nwith the target overall good production rate (which is derived by target speed, (expected) setup time, target downtime ratio and target scrap ratio).\nIf the target values are set properly, this is the perfect measure to evaluate the performance of this job \/ product group.\nThis basically says how well the production was running compared to the expectations.\nThe greatest advantage over OEE is that the 'WonProductivity' percentage allows comparison of jobs \/ product groups\nwhich not depends on the necessary setup effort because of different previous jobs."
  total: ProducedPerformanceValue!
}

"Values to measure the performance of a job \/ product group in a specific discipline (speed, setup, downtime, scrap) or in total."
type ProducedPerformanceValue {
  "The value that was measured during production of this job \/ product group.\nOn product groups, this is the average value per job."
  actualValue: Float
  "Minutes that were lost compared to the expectation in total \/ because of this discipline\n(-&gt; negative values indicate that it was better than expected)."
  lostTimeInMin: Float
  "The target\/expected value that should be reached for this job \/ product group.\nIs 'null' if no target value was given for this job \/ product group.\nOn product groups, this is the average value per job."
  targetValue: Float
  "Describes how the 'TargetValue' for this job was defined.\nis 'null' for product groups."
  targetValueSource: TargetValueSource
  "The unit of 'ActualValue' and 'TargetValue'.\n(if the unit needs to be translated, the corresponding i18n tag is provided here; for example '{{ label.items }}\/{{ label.minutesShort }}')."
  unit: String!
  "Percentage of productivity that was won compared to the expectation in total \/ because of this discipline\n(-&gt; negative values indicate that it was worse than expected).\nFor the total value, this is the relation between 'ActualValue' and 'TargetValue'\n(-&gt; this 'total productivity indicator' is the perfect value to compare jobs \/ product groups).\nFor the disciplines, this is difference of 'ActualValue' and 'TargetValue' in relation to the total productivity\n(-&gt; sum of all disciplines equals total percentage)."
  wonProductivity: Float
}

"Some attributes are based on numeric variables, where nearly equal values should be considered as one (bucket) value."
type ProductGroupBucketAttributeValue {
  "The string representation of the buckets value (like '175-225')."
  formattedValue: String
  "The unit of the 'FormattedValue'."
  unit: String!
}

type ProductGroupChangeMachineNotePayload {
  changedProductGroup: PaperSackProductGroup
  errors: [ProductGroupChangeMachineNoteError!]
}

type ProductGroupChangeMachineTargetSpeedPayload {
  changedProductGroup: PaperSackProductGroup
  errors: [ProductGroupChangeMachineTargetSpeedError!]
}

type ProductGroupChangeOverallNotePayload {
  changedProductGroup: PaperSackProductGroup
  errors: [ProductGroupChangeOverallNoteError!]
}

"Information about the production approval event of this job.\nThe production approval can be performed on the OperatorUI (usually by the shift supervisor)."
type ProductionApprovalEvent {
  "Signature of the person who approved the production (usually shift supervisor).\nThis string is the output of the Angular canvas component."
  signature: String!
  "Associated date of the production approval event."
  timestamp: DateTime!
}

"Production status of the machine.\nEach machine type defines its own status and assigns it to a generic status category.\nThe production status might be changed automatically by RUBY or a user."
type ProductionStatus {
  "Generic status category which this status is assigned to."
  category: ProductionStatusCategory
  "Unique id for this status."
  id: Int
  "The timestamp the machine went into this production status."
  startTime: DateTime
}

"Cumulated minutes the machine was in each production status for the queried time span or job.\nAlso, the total times are provided.\nThese values are the base for many KPI calculations (like OEE)."
type ProductionTimes {
  "Time the machine was in production status 'DownTime', but this excludes job-related downtimes.\nThis also includes times the machine was in production status 'Offline' or 'InvalidData'."
  generalDownTimeInMin: Float!
  "Time the machine was in production status 'DownTime',\nif this downtime was job-related (this only exists on paper sack machines)."
  jobRelatedDownTimeInMin: Float!
  "Time that is not relevant for KPI calculation\n(For time span queries, this only includes 'ScheduledNonProductionTimeInMin'.\nFor job queries, this additionally includes 'GeneralDownTimeInMin' and time related to other jobs.)"
  notQueryRelatedTimeInMin: Float!
  "Time the machine was in production status 'Production'."
  productionTimeInMin: Float!
  "Time the machine was in production status 'ScheduledNonProduction'."
  scheduledNonProductionTimeInMin: Float!
  "Time the machine was in production status 'Scrap'.\nThis production status does not exist on paper sack machines."
  scrapTimeInMin: Float!
  "Time the machine was in production status 'Setup'"
  setupTimeInMin: Float!
  "Relevant time for KPI calculation"
  totalPlannedProductionTimeInMin: Float!
  "Total calendar time\n(= TotalPlannedProductionTimeInMin + NotQueryRelatedTimeInMin)"
  totalTimeInMin: Float!
}

"GraphQL query class for product group entity of paper sack department."
type Query @authorize {
  "Query to get settings of the configured RUBY dashboards that are visible for the logged-in user.\nThe dashboard settings service.\nThe userId from the bearer token.\nIf set, only dashboards of this machine department are returned.\nThe cancellation token."
  dashboardSettings(machineDepartmentFilter: MachineDepartment): [DashboardSettings!]!
  "Query to get settings of a RUBY dashboard.\nThis is only successful if the dashboard is visible for the logged-in user.\nThe dashboard settings service.\nThe userId from the bearer token.\nThe database id of the dashboard.\nThe cancellation token."
  dashboardSettingsById(dashboardId: String!): DashboardSettings!
  "Query to get settings of the whole RUBY instance."
  globalSettings: GlobalSettings
  "Query to get data of one machine by id at one moment (either live or at query timestamp).\n\n\n**Returns:**\nA Machine."
  machine("The machine id." machineId: String! "If this is null, the current status of the machine is queried. Otherwise, the historic values on this timestamp are returned." timestamp: DateTime): Machine! @authorize(roles: [ "go-general" ])
  "Query to get data of all machine at one moment (either live or at query timestamp).\n\n\n**Returns:**\nQueryable Machines."
  machines(order: [MachineSortInput!] "If this is null, the current status of the machine is queried. Otherwise, the historic values on this timestamp are returned." timestamp: DateTime where: MachineFilterInput): [Machine!]! @authorize(roles: [ "go-general" ])
  "Query to get data of one machine by id during a time span.\nFor performance reasons, the queried time span must be shorter than 7 days.\n\n\n**Returns:**\nA MachineTimeSpan."
  machineTimeSpan("The start timestamp of the query." from: DateTime! "The machine id." machineId: String! "The end timestamp of the query." to: DateTime!): MachineTimeSpan! @authorize(roles: [ "go-general" ])
  "Query to get one material lot by its unique id."
  materialLot(materialLotId: String!): MaterialLot @authorize(roles: [ "go-general" ])
  "Query to get a list of material lots."
  materialLots("If set, only lots produced after this timestamp are returned." from: DateTime "If set, only lots produced on machines of this machine department are returned." machineDepartmentFilter: MachineDepartment "If set, only lots produced on machines of this machine family are returned." machineFamilyFilter: MachineFamily "If set, only lots produced on this machine are returned." machineIdFilter: String "If set, only lots are returned where the material lot id fits to this regex expression." regexFilter: String "Number of lots to be skipped (can be used for pagination)." skip: Int = 0 "Number of lots to be returned (can be used for pagination)." take: Int = 20 "If set, only lots produced before this timestamp are returned." to: DateTime): MaterialLotsCollectionSegment @authorize(roles: [ "go-general" ])
  "Query to get one paper sack product group by its ID."
  paperSackProductGroup("Unique identifier of the product group" id: String!): PaperSackProductGroup! @authorize(roles: [ "go-general" ])
  "Query to get a list with product groups of paper sack department."
  paperSackProductGroups("If set, only product groups are returned where the id, the friendly name or one of the productIds fits to this regex expression." regexFilter: String "Number of product groups to be skipped (can be used for pagination)." skip: Int = 0 "Option to sort the query results." sortOption: ProductGroupSortOption! = LAST_PRODUCTION_DATE_DESCENDING "Number of product groups to be returned (can be used for pagination)." take: Int = 20): PaperSackProductGroupsCollectionSegment @authorize(roles: [ "go-general" ])
  "Query to get one physical asset by id.\n\n\n**Returns:**\nA PhysicalAsset."
  physicalAsset("The physical asset id." physicalAssetId: String!): PhysicalAsset! @authorize(roles: [ "go-general" ])
  "Query to get one physical asset test specification by capability test type.\n\n\n**Returns:**\nA CapabilityTestSpecification."
  physicalAssetCapabilityTestSpecification("The capability test type." capabilityTestType: CapabilityTestType!): CapabilityTestSpecification! @authorize(roles: [ "go-general" ])
  "Query to get a list of all physical assets test specification.\n\n\n**Returns:**\nA CapabilityTestSpecification."
  physicalAssetCapabilityTestSpecifications: [CapabilityTestSpecification!]! @authorize(roles: [ "go-general" ])
  "Query to get a list of all physical assets.\n\n\n**Returns:**\nPhysicalAssets."
  physicalAssets("If set, only physical assets where LastChange is greater than  are returned." lastChangeFilter: DateTime "Only physical assets where which are matching the group of  are returned." physicalAssetsFilter: PhysicalAssetsFilter! = UTILISABLE "If set, only physical assets where PhysicalAssetType is equal to  are returned." physicalAssetTypeFilter: PhysicalAssetType): [PhysicalAsset!]! @authorize(roles: [ "go-general" ])
  "Query to get physical asset settings.\n\n\n**Returns:**\nA PhysicalAssetSettings."
  physicalAssetSettings: PhysicalAssetSettings! @authorize(roles: [ "go-general" ])
  "Query to get one produced job by the unique combination of machine id and job id."
  producedJob(jobId: String! machineId: String!): ProducedJob! @authorize(roles: [ "go-general" ])
  "Query to get a list of the last produced jobs."
  producedJobs("If set, only jobs produced after this timestamp are returned." from: DateTime "If set, only jobs produced on machines of this machine department are returned." machineDepartmentFilter: MachineDepartment "If set, only jobs produced on machines of this machine family are returned." machineFamilyFilter: MachineFamily "If set, only jobs produced on this machine are returned." machineIdFilter: String "If set, only jobs are returned where the job id, the product id or the customer fit to this regex expression." regexFilter: String "Number of jobs to be skipped (can be used for pagination)." skip: Int = 0 "Number of jobs to be returned (can be used for pagination)." take: Int = 20 "If set, only jobs produced before this timestamp are returned." to: DateTime): ProducedJobsCollectionSegment @authorize(roles: [ "go-general" ])
  "Query to get settings of the logged-in user."
  userSettings: UserSettings
}

"A refurbishing operation."
type RefurbishingOperation {
  "Date the operation was ended.\n[Source: Operation]"
  endDateTime: DateTime
  "Unique identifier of the equipment physical asset mapping the operation is associated with.\n[Source: Operation]"
  equipmentPhysicalAssetMappingId: String!
  "The additional note for this operation.\n[Source: Operation]"
  note: String
  "Type of the operation.\n[Source: Operation]"
  operationType: OperationType!
  "Id of the user who carried out the operation.\n[Source: Operation]"
  operatorUserId: String!
  "Unique identifier of the physical asset the operation is associated with.\n[Source: Operation]"
  physicalAssetId: String!
  "Date the operation was started.\n[Source: Operation]"
  startDateTime: DateTime!
}

"Status of a machines licenses for RUBY extensions and connection modules."
type RubyLicenses {
  "Timestamp on which the RUBY Anilox license expires."
  expiryDateOfAniloxLicense: DateTime
  "Timestamp on which the RUBY Check license expires."
  expiryDateOfCheckLicense: DateTime
  "Timestamp on which the Connect 4 Flow license expires."
  expiryDateOfConnect4FlowLicense: DateTime
  "Timestamp on which the RUBY Go license expires."
  expiryDateOfGoLicense: DateTime
  "Timestamp on which the RUBY Track license expires."
  expiryDateOfTrackLicense: DateTime
  "True, if the machine has a valid license for RUBY Anilox."
  hasValidAniloxLicense: Boolean!
  "True, if the machine has a valid license for RUBY Check."
  hasValidCheckLicense: Boolean!
  "True, if the machine has a valid license for Connect 4 Flow."
  hasValidConnect4FlowLicense: Boolean!
  "True, if the RUBY instance has a valid license for RUBY Go."
  hasValidGoLicense: Boolean!
  "True, if the machine has a valid license for RUBY Track."
  hasValidTrackLicense: Boolean!
}

"A scrapping operation."
type ScrappingOperation {
  "Date the operation was ended.\n[Source: Operation]"
  endDateTime: DateTime
  "Unique identifier of the equipment physical asset mapping the operation is associated with.\n[Source: Operation]"
  equipmentPhysicalAssetMappingId: String!
  "The additional note for this operation.\n[Source: Operation]"
  note: String
  "Type of the operation.\n[Source: Operation]"
  operationType: OperationType!
  "Id of the user who carried out the operation.\n[Source: Operation]"
  operatorUserId: String!
  "Unique identifier of the physical asset the operation is associated with.\n[Source: Operation]"
  physicalAssetId: String!
  "Date the operation was started.\n[Source: Operation]"
  startDateTime: DateTime!
}

type SnapshotValueOfBoolean {
  lastValue: Boolean!
  unit: String
}

type SnapshotValueOfString {
  lastValue: String
  unit: String
}

"The values of a variable\/sub-entity (for example a string set value, or (in case of rolls) the corresponding produced job) can be changed during production of a job\/roll\/etc.In these cases it is not always easy to determine just one single value for the variable that stands for the whole job\/roll\/etc.This data model provides more information, so the user might get an indication if the value was changed during the job\/roll\/etc.This is only supported for values that can be derived from MachineSnapshots."
type SnapshotValuesDuringProductionOfNullableOfBoolean {
  "All distinct values in SI unit that were active during the job\/roll\/etc.Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  distinctValues(limit: Int! = 100): [Boolean]
  "The value on the end of the job\/roll\/etc in SI unit.If the job\/roll\/etc is still active, this is the current live-value."
  lastValue: Boolean
  valueAtQueryTimestamp: Boolean
  "The value with the longest duration during the job\/roll\/etc in SI unit. Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  valueWithLongestDuration: Boolean
}

"The values of a variable\/sub-entity (for example a string set value, or (in case of rolls) the corresponding produced job) can be changed during production of a job\/roll\/etc.In these cases it is not always easy to determine just one single value for the variable that stands for the whole job\/roll\/etc.This data model provides more information, so the user might get an indication if the value was changed during the job\/roll\/etc.This is only supported for values that can be derived from MachineSnapshots."
type SnapshotValuesDuringProductionOfNullableOfInt32 {
  "All distinct values in SI unit that were active during the job\/roll\/etc.Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  distinctValues(limit: Int! = 100): [Int]
  "The value on the end of the job\/roll\/etc in SI unit.If the job\/roll\/etc is still active, this is the current live-value."
  lastValue: Int
  valueAtQueryTimestamp: Int
  "The value with the longest duration during the job\/roll\/etc in SI unit. Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  valueWithLongestDuration: Int
}

"The values of a variable\/sub-entity (for example a string set value, or (in case of rolls) the corresponding produced job) can be changed during production of a job\/roll\/etc.In these cases it is not always easy to determine just one single value for the variable that stands for the whole job\/roll\/etc.This data model provides more information, so the user might get an indication if the value was changed during the job\/roll\/etc.This is only supported for values that can be derived from MachineSnapshots."
type SnapshotValuesDuringProductionOfNullableOfPaperSackCutType {
  "All distinct values in SI unit that were active during the job\/roll\/etc.Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  distinctValues(limit: Int! = 100): [PaperSackCutType]
  "The value on the end of the job\/roll\/etc in SI unit.If the job\/roll\/etc is still active, this is the current live-value."
  lastValue: PaperSackCutType
  valueAtQueryTimestamp: PaperSackCutType
  "The value with the longest duration during the job\/roll\/etc in SI unit. Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  valueWithLongestDuration: PaperSackCutType
}

"The values of a variable\/sub-entity (for example a string set value, or (in case of rolls) the corresponding produced job) can be changed during production of a job\/roll\/etc.In these cases it is not always easy to determine just one single value for the variable that stands for the whole job\/roll\/etc.This data model provides more information, so the user might get an indication if the value was changed during the job\/roll\/etc.This is only supported for values that can be derived from MachineSnapshots."
type SnapshotValuesDuringProductionOfString {
  "All distinct values in SI unit that were active during the job\/roll\/etc.Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  distinctValues(limit: Int! = 100): [String]
  "The value on the end of the job\/roll\/etc in SI unit.If the job\/roll\/etc is still active, this is the current live-value."
  lastValue: String
  valueAtQueryTimestamp: String
  "The value with the longest duration during the job\/roll\/etc in SI unit. Because of performance reasons, it is not possible to subscribe to this property (-> returns 'null')."
  valueWithLongestDuration: String
}

"Speed histogram values for one speed level"
type SpeedHistogramItem {
  "Capacity utilization rate in percent during the time the machine was running at this speed level.\nThis is the total good production rate (which includes losses due to scrap and job-related downtimes) divided by the maximum machine speed.\nThis value is 'null', if the machine was not running long enough at that speed level (minimum 1 hour).\nThe higher the capacity utilization rate is, the better is the productivity.\nFor example:\nA machine can run maximal 400 items\/min.\nIf the machine runs at speed level 200 items\/min, the capacity utilization rate can maximum be 50 %.\nIn this example, we don't have any downtimes and have a scrap rate of 2 % (-&gt; 4 items\/min scrap).\nThis results in a capacity utilization rate of 49 % (196 \/ 400) at speed level 200.\nIf the machine runs at speed level 300 items\/min, the capacity utilization rate can maximum be 75 %.\nBut in this example, we get a lot of downtimes (30 %) and scrap rate raises to 10 % (total good production rate: 300 * 0.70 - 300 * 0.1 = 180).\nThis results in a capacity utilization rate of 45 % (180 \/ 400) at speed level 300.\nTherefore, the productivity is better at 200 items\/min."
  capacityUtilizationRate: Float
  "Duration in minutes the machine was running at this speed level.\nThis also includes job-specific downtimes happening at this speed level as they affect productivity.\nCertain situations, like roll changes or ramp-ups, are excluded to maintain an accurate picture."
  durationInMin: Float!
  "Bucket value of this speed level."
  speedLevel: Int!
}

"GraphQL subscription for physical asset entity."
type Subscription @authorize {
  "Subscribe to the current status of the whole machine entity (this will not update, if the machine time changes)."
  machineChanged(machineId: String!): Machine! @authorize(roles: [ "go-general" ])
  "Subscribe to the current status of the machine time."
  machineTimeChanged(machineId: String!): DateTime @authorize(roles: [ "go-general" ])
  "Subscribe to the current status of the physical asset."
  physicalAssetChanged(physicalAssetTypeFilter: PhysicalAssetType): PhysicalAsset! @authorize(roles: [ "go-general" ])
  "Subscribe to the current status of the physical asset."
  physicalAssetScrapped(physicalAssetTypeFilter: PhysicalAssetType): PhysicalAsset! @authorize(roles: [ "go-general" ])
}

type SummedSnapshotValue {
  "The unit of the value."
  unit: String
  "The summed up value within this time span."
  value: Float
}

"A generic value that can be measured and can be tested against a set value."
type TestableValueWithUnitOfDouble {
  "The date and time when the value was measured."
  measuredAt: DateTime
  "The generic measured value."
  measuredValue: Float
  "The optimal value the measured value can be tested against."
  setValue: Float
  "The unit of the value."
  unit: String
}

type Thickness {
  "Value for the average actual thickness for the film on this roll.\n[Source: MachineSnapshots]"
  average: AverageSnapshotValue!
  "Value for the average 2-sigma value of the film on this roll.\n[Source: MachineSnapshots]"
  twoSigma: AverageSnapshotValue!
}

"A period of time."
type TimeRange {
  "Start timestamp of the time range in UTC."
  from: DateTime!
  "End timestamp of the time range in UTC."
  to: DateTime!
}

"Downtime entry of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackDowntimeHistoryEntry implements TrackHistoryEntry {
  "Is true, if this downtime occurred before the production approval\nand also the production approval feature is activated (in the AdminUI)."
  beforeApproval: Boolean!
  "A free text that gives more information to this downtime.\nThis information is either entered by the operator (OperatorUI) or by the manager (TRACK)."
  comment: String
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Category of the downtime reason (like machine, organization, ...).\nThis is an i18n text key in old format (like REASON.MACHINE).\nThis information is either detected by RUBY (ProblemAnalyzer),\nentered by the operator (OperatorUI) or corrected by the manager (TRACK)."
  firstLevelReason: String
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Is true, if downtime reason and location were detected by RUBY (ProblemAnalyzer)."
  isDetectedByRuby: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "The downtime location (like valve unit 1, opening station, ...).\nThis is an i18n text key in old format (like LOCATION.VALVE_UNIT_1).\nThis information is either detected by RUBY (ProblemAnalyzer),\nentered by the operator (OperatorUI) or corrected by the manager (TRACK)."
  location: String
  "The full name of the last user that changed the downtime reason\/location or the comment."
  reportingUserFullName: String
  "The Keycloak identifier of the last user that changed the downtime reason\/location or the comment."
  reportingUserId: String
  "The actual downtime reason (like jam, missing material, ...).\nThis is an i18n text key in old format (like REASON.MACHINE.JAM).\nThis information is either detected by RUBY (ProblemAnalyzer),\nentered by the operator (OperatorUI) or corrected by the manager (TRACK)."
  secondLevelReason: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"Offline entry of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackOfflineHistoryEntry implements TrackHistoryEntry {
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"Production break entry of the RUBY Track production history.\nThese production breaks are times that are counted as scheduled non-production (lunch break, scheduled cleaning shift, weekend, holiday, ...)\nand also this is shown in job history if the job got interrupted by another job.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackProductionBreakHistoryEntry implements TrackHistoryEntry {
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"Production entry of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackProductionHistoryEntry implements TrackHistoryEntry {
  "Average value of the machine speed during the machine was in status production\n(minor stops are not considered here)."
  averageSpeed: Float
  "Is true, if this production time was before the production approval\nand also the production approval feature is activated (in the AdminUI)."
  beforeApproval: Boolean!
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Count of minor stops which occurred in between the production times during this time span.\nMinor stops are downtimes that are shorter than the 'minor stop threshold' (configured in AdminUI).\nIs null, if there are no minor stops in this time span."
  minorStopsCount: Float
  "Total duration of minor stops (in minutes) which occurred in between the production times during this time span.\nMinor stops are downtimes that are shorter than the 'minor stop threshold' (configured in AdminUI)\nIs null, if there are no minor stops in this time span."
  minorStopsDurationInMin: Float
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"Scrap entry of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackScrapHistoryEntry implements TrackHistoryEntry {
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"Setup entry of the RUBY Track production history.\nThese production history entries are like the ones displayed in RUBY Track Operator UI."
type TrackSetupHistoryEntry implements TrackHistoryEntry {
  "Is true, if this setup time was before the production approval\nand also the production approval feature is activated (in the AdminUI)."
  beforeApproval: Boolean!
  "End position (total operation counter) of the history entry.\nIs null, if the history entry is active.\nThis information is necessary when a history entry should be changed."
  endPosition: Float
  "End timestamp of the history entry.\nIs null, if the history entry is active."
  endTime: DateTime
  "Type of the history entry.\nThis also defines which additional data will be available."
  entryType: TrackHistoryEntryType!
  "Is true, if the operator still needs to enter information for this entry (for example: downtime reason)."
  hasPendingToDo: Boolean!
  "Id of produced job (unique for the machine).\nIs null, if this history entry is not job-related."
  jobId: String
  "Start position (total operation counter) of the history entry.\nThis information is necessary when a history entry should be changed."
  startPosition: Float!
  "Start timestamp of the history entry."
  startTime: DateTime!
}

"A generic value that was tracked at some point in time."
type TrackedValueOfCleaningOperationType {
  "The date and time when the value was tracked."
  trackedAt: DateTime!
  "The generic tracked value."
  value: CleaningOperationType!
}

"A generic value that was tracked at some point in time."
type TrackedValueOfString {
  "The date and time when the value was tracked."
  trackedAt: DateTime!
  "The generic tracked value."
  value: String!
}

type UnauthorizedAccessError implements Error {
  message: String!
}

type UserIdNotFoundError implements Error {
  message: String!
}

"Settings for the logged-in user."
type UserSettings {
  "The database id of the default extrusion dashboard of the logged-in user."
  favoriteDashboardDatabaseIdExtrusion: String
  "The database id of the default other dashboard of the logged-in user."
  favoriteDashboardDatabaseIdOther: String
  "The database id of the default papersack dashboard of the logged-in user."
  favoriteDashboardDatabaseIdPaperSack: String
  "The database id of the default printing dashboard of the logged-in user."
  favoriteDashboardDatabaseIdPrinting: String
  "Language tag (like 'en-US') of the logged-in user."
  languageTag: String
  "The option the logged-in user chose on extrusion machine family filter."
  selectedExtrusionMachineFamily: MachineFamily
  "The option the logged-in user chose on machine department filter."
  selectedMachineDepartment: MachineDepartment
  "The option the logged-in user chose on other machine family filter."
  selectedOtherMachineFamily: MachineFamily
  "The option the logged-in user chose on paper sack machine family filter."
  selectedPaperSackMachineFamily: MachineFamily
  "The option the logged-in user chose on printing machine family filter."
  selectedPrintingMachineFamily: MachineFamily
  "Unit representation system of the logged-in user."
  unitRepresentation: UnitRepresentation
}

type UserSettingsChangeExtrusionMachineFamilyPayload {
  errors: [UserSettingsChangeExtrusionMachineFamilyError!]
  extrusionMachineFamily: MachineFamily
}

type UserSettingsChangeFavoriteDashboardExtrusionPayload {
  dashboardId: String
  errors: [UserSettingsChangeFavoriteDashboardExtrusionError!]
}

type UserSettingsChangeFavoriteDashboardOtherPayload {
  dashboardId: String
  errors: [UserSettingsChangeFavoriteDashboardOtherError!]
}

type UserSettingsChangeFavoriteDashboardPaperSackPayload {
  dashboardId: String
  errors: [UserSettingsChangeFavoriteDashboardPaperSackError!]
}

type UserSettingsChangeFavoriteDashboardPrintingPayload {
  dashboardId: String
  errors: [UserSettingsChangeFavoriteDashboardPrintingError!]
}

type UserSettingsChangeLanguagePayload {
  errors: [UserSettingsChangeLanguageError!]
  languageTag: String
}

type UserSettingsChangeMachineDepartmentPayload {
  errors: [UserSettingsChangeMachineDepartmentError!]
  machineDepartment: MachineDepartment
}

type UserSettingsChangeOtherMachineFamilyPayload {
  errors: [UserSettingsChangeOtherMachineFamilyError!]
  otherMachineFamily: MachineFamily
}

type UserSettingsChangePaperSackMachineFamilyPayload {
  errors: [UserSettingsChangePaperSackMachineFamilyError!]
  paperSackMachineFamily: MachineFamily
}

type UserSettingsChangePrintingMachineFamilyPayload {
  errors: [UserSettingsChangePrintingMachineFamilyError!]
  printingMachineFamily: MachineFamily
}

type UserSettingsChangeUnitSystemPayload {
  errors: [UserSettingsChangeUnitSystemError!]
  unitRepresentation: UnitRepresentation
}

"A generic value and the related unit."
type ValueWithUnitOfDouble {
  "The unit of the generic value."
  unit: String
  "The generic value in SI unit."
  value: Float
}

"A generic value and the related unit."
type ValueWithUnitOfInt32 {
  "The unit of the generic value."
  unit: String
  "The generic value in SI unit."
  value: Int
}

"A visual capability test specification."
type VisualCapabilityTestSpecification implements CapabilityTestSpecification {
  "Unique identifier of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestSpecificationId: String!
  "Type of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestType: CapabilityTestType!
  "Date of the creation of the capability test specification.\n[Source: CapabilityTestSpecification]"
  createdAt: DateTime!
  "Description of the capability test specification.\n[Source: CapabilityTestSpecification]"
  description: String
  "Version of the capability test specification.\n[Source: CapabilityTestSpecification]"
  version: Int!
}

"A volume capability test result."
type VolumeCapabilityTestResult {
  "Unique identifier of the capability test result.\n[Source: CapabilityTestResult]"
  capabilityTestResultId: String!
  "Unique identifier of the used capability test specification.\n[Source: CapabilityTestResult]"
  capabilityTestSpecificationId: String!
  "Specifies whether the test passed when it was compared against the specification.\n[Source: CapabilityTestResult]"
  isPassed: Boolean!
  "The additional note for this test result.\n[Source: CapabilityTestResult]"
  note: String
  "Unique identifier of the tested physical asset.\n[Source: CapabilityTestResult]"
  physicalAssetId: String!
  "Date the physical asset was tested.\n[Source: CapabilityTestResult]"
  testDateTime: DateTime!
  "Id of the user who tested the physical asset.\n[Source: CapabilityTestResult]"
  testerUserId: String!
  "The volume measured by the tester.\n[Source: VolumeCapabilityTestResult]"
  volume: Float!
}

"An volume capability test specification."
type VolumeCapabilityTestSpecification implements CapabilityTestSpecification {
  "Unique identifier of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestSpecificationId: String!
  "Type of the capability test specification.\n[Source: CapabilityTestSpecification]"
  capabilityTestType: CapabilityTestType!
  "Date of the creation of the capability test specification.\n[Source: CapabilityTestSpecification]"
  createdAt: DateTime!
  "Description of the capability test specification.\n[Source: CapabilityTestSpecification]"
  description: String
  "The flag which signals if the deviation values are relative.\n[Source: VolumeCapabilityTestSpecification]"
  isRelative: Boolean!
  "Version of the capability test specification.\n[Source: CapabilityTestSpecification]"
  version: Int!
  "The lower deviation limit of the measured volume.\n[Source: VolumeCapabilityTestSpecification]"
  volumeDeviationLowerLimit: Float
  "The upper deviation limit of the measured volume.\n[Source: VolumeCapabilityTestSpecification]"
  volumeDeviationUpperLimit: Float
}

union DashboardSettingsCreateDashboardError = ParameterInvalidError | UserIdNotFoundError | InternalServiceError

union DashboardSettingsDeleteDashboardError = UserIdNotFoundError | IdNotFoundError | UnauthorizedAccessError | ParameterInvalidError | InternalServiceError

union DashboardSettingsEditDashboardError = ParameterInvalidError | UserIdNotFoundError | IdNotFoundError | InternalServiceError

union GlobalSettingsChangeRubyCloudEnabledError = ParameterInvalidError | InternalServiceError

union GlobalSettingsChangeRubyFriendlyNameError = ParameterInvalidError | InternalServiceError

union GlobalSettingsChangeRubyUserBehaviorTrackingEnabledError = ParameterInvalidError | InternalServiceError

union GlobalSettingsChangeTimeZoneError = ParameterInvalidError | InternalServiceError

union GlobalSettingsChangeTimeZoneIpAddressWithPortError = ParameterInvalidError | InternalServiceError

union GlobalSettingsChangeUserBehaviorTrackingUrlError = ParameterInvalidError | InternalServiceError

union PhysicalAssetUpdateSettingsError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateAniloxCapabilityTestResultError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateAniloxError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateCleaningOperationError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateRefurbishingAniloxOperationError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateScrappingOperationError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsCreateVolumeCapabilityTestResultError = ParameterInvalidError | InternalServiceError

union PhysicalAssetsUpdateAniloxError = ParameterInvalidError | InternalServiceError

union ProducedJobChangeMachineTargetDownTimeInMinError = ParameterInvalidError | InternalServiceError

union ProducedJobChangeMachineTargetScrapCountDuringProductionError = ParameterInvalidError | InternalServiceError

union ProducedJobChangeMachineTargetSetupTimeInMinError = ParameterInvalidError | InternalServiceError

union ProducedJobChangeMachineTargetSpeedError = ParameterInvalidError | InternalServiceError

union ProductGroupChangeMachineNoteError = ParameterInvalidError | InternalServiceError

union ProductGroupChangeMachineTargetSpeedError = ParameterInvalidError | InternalServiceError

union ProductGroupChangeOverallNoteError = ParameterInvalidError | InternalServiceError

union UserSettingsChangeExtrusionMachineFamilyError = UserIdNotFoundError | InternalServiceError

union UserSettingsChangeFavoriteDashboardExtrusionError = UserIdNotFoundError | IdNotFoundError | UnauthorizedAccessError | InternalServiceError

union UserSettingsChangeFavoriteDashboardOtherError = UserIdNotFoundError | IdNotFoundError | UnauthorizedAccessError | InternalServiceError

union UserSettingsChangeFavoriteDashboardPaperSackError = UserIdNotFoundError | IdNotFoundError | UnauthorizedAccessError | InternalServiceError

union UserSettingsChangeFavoriteDashboardPrintingError = UserIdNotFoundError | IdNotFoundError | UnauthorizedAccessError | InternalServiceError

union UserSettingsChangeLanguageError = ParameterInvalidError | UserIdNotFoundError | InternalServiceError

union UserSettingsChangeMachineDepartmentError = UserIdNotFoundError | InternalServiceError

union UserSettingsChangeOtherMachineFamilyError = UserIdNotFoundError | InternalServiceError

union UserSettingsChangePaperSackMachineFamilyError = UserIdNotFoundError | InternalServiceError

union UserSettingsChangePrintingMachineFamilyError = UserIdNotFoundError | InternalServiceError

union UserSettingsChangeUnitSystemError = UserIdNotFoundError | InternalServiceError

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

"A request to create an anilox capability test result."
input CreateAniloxCapabilityTestResultRequestInput {
  "The type of the anilox error."
  aniloxCapabilityErrorType: AniloxCapabilityErrorType!
  "The end position on the anilox."
  endPositionOnAnilox: Float
  "The additional note for this test result."
  note: String
  "Unique identifier of the tested physical asset."
  physicalAssetId: String!
  "The start position on the anilox."
  startPositionOnAnilox: Float!
  "Date the physical asset was tested."
  testDateTime: DateTime!
}

"A request to create a physical asset of type anilox."
input CreateAniloxPhysicalAssetRequestInput {
  "Date of the delivery of the physical asset."
  deliveredAt: DateTime
  "Description of the physical asset to create."
  description: String
  "Engraving of the physical asset to create."
  engraving: String
  "Initial time usage counter of the physical asset to create."
  initialTimeUsageCounter: Long
  "Initial usage counter of the physical asset to create."
  initialUsageCounter: Long
  "Inner diameter of the physical asset to create."
  innerDiameter: Float
  "Flag which signals if the physical asset to create is a sleeve."
  isSleeve: Boolean!
  "Manufacturer of the physical asset to create."
  manufacturer: String!
  "The last measured volume of the physical asset to create."
  measuredVolumeValue: Float
  "Outer diameter of the physical asset to create."
  outerDiameter: Float!
  "Preferred usage location of the physical asset to create."
  preferredUsageLocation: String
  "Print width of the physical asset to create."
  printWidth: Float!
  "List of unique scan codes (e.g. QR codes) identifying the physical asset."
  scanCodes: [String!]!
  "Screen of the physical asset to create."
  screen: Int!
  "Mandatory Serial number of the physical asset to create."
  serialNumber: String!
  "Set optical density of the physical asset to create."
  setOpticalDensityValue: Float
  "Set volume of the physical asset to create."
  setVolumeValue: Float!
}

"A request to create a physical asset cleaning operation."
input CreateCleaningOperationRequestInput {
  "Type of the cleaning operation."
  cleaningOperationType: CleaningOperationType!
  "The additional note for this operation."
  note: String
  "Unique identifier of the sc physical asset."
  physicalAssetId: String!
  "The flag which signals if the cleaning resets past volume defects."
  resetVolumeDefects: Boolean!
  "Date the physical asset was cleaned."
  startDateTime: DateTime!
}

"Request item to create or edit a dashboard.\nAll widget settings will be overwritten - even if they are null."
input CreateOrEditConfiguredDashboardRequestInput {
  "The dashboard id of the dashboard to be edited or created."
  dashboardId: String
  "The WuH department this dashboards is dedicated for."
  department: MachineDepartment!
  "The friendly name of this dashboard which was given by the user.\nThere should not be two public dashboards with the same friendly name."
  friendlyName: String!
  "Is true, if all users can see this dashboard.\nIs false, if only the creator can see it."
  isPublic: Boolean!
  "Settings for the 1st widget.\nIf this is null, this widget is blank."
  widget1: DashboardWidgetSettingsInput
  "Settings for the 2nd widget.\nIf this is null, this widget is blank."
  widget2: DashboardWidgetSettingsInput
  "Settings for the 3rd widget.\nIf this is null, this widget is blank."
  widget3: DashboardWidgetSettingsInput
  "Settings for the 4th widget.\nIf this is null, this widget is blank."
  widget4: DashboardWidgetSettingsInput
  "Settings for the 5th widget.\nIf this is null, this widget is blank."
  widget5: DashboardWidgetSettingsInput
  "Settings for the 6th widget.\nIf this is null, this widget is blank."
  widget6: DashboardWidgetSettingsInput
}

"A request to create a anilox physical asset refurbishing operation."
input CreateRefurbishingAniloxOperationRequestInput {
  "Engraving of the refurbished anilox physical asset."
  engraving: String
  "Optional overwrite for the current manufacturer."
  manufacturerOverwrite: String
  "The measured volume of the refurbished anilox physical asset."
  measuredVolumeValue: Float
  "The additional note for this operation."
  note: String
  "Unique identifier of the sc physical asset."
  physicalAssetId: String!
  "Date the physical asset is refurbished."
  refurbishedDateTime: DateTime!
  "Screen of the refurbished anilox physical asset."
  screen: Int!
  "Optional overwrite for the current serial number."
  serialNumberOverwrite: String
  "Set volume value of the refurbished anilox physical asset."
  setVolumeValue: Float!
}

"A request to create a physical asset scrapping operation."
input CreateScrappingOperationRequestInput {
  "The additional note for this operation."
  note: String
  "Unique identifier of the sc physical asset."
  physicalAssetId: String!
  "Date the physical asset is scrapped."
  scrapDateTime: DateTime!
}

"A request to create a physical asset test result."
input CreateVolumeCapabilityTestResultRequestInput {
  "The additional note for this test result."
  note: String
  "Unique identifier of the tested physical asset."
  physicalAssetId: String!
  "Date the physical asset was tested."
  testDateTime: DateTime!
  "The volume measured by the tester."
  volume: Float!
}

input DashboardSettingsCreateDashboardInput {
  createDashboardRequest: CreateOrEditConfiguredDashboardRequestInput!
}

input DashboardSettingsDeleteDashboardInput {
  dashboardId: String!
}

input DashboardSettingsEditDashboardInput {
  editDashboardRequest: CreateOrEditConfiguredDashboardRequestInput!
}

input DashboardWidgetSettingsInput {
  "An optional free text that can be used for specific widget settings."
  additionalSetting: String
  "List with unique machine identifiers (usually WuH equipment number, like: \"EQ12345\") of all machines that should be shown on this widget."
  machineIds: [String!]!
  "Reference to the entry in the frontend's widget catalog.\nThis is not a unique identifier for the widget instance:\nWidgets with the same WidgetCatalogId can be configured on the same or other dashboards but with different machine(s)."
  widgetCatalogId: String!
}

input GlobalSettingsChangeRubyCloudEnabledInput {
  cloudEnabled: Boolean!
}

input GlobalSettingsChangeRubyFriendlyNameInput {
  rubyFriendlyName: String
}

input GlobalSettingsChangeRubyUserBehaviorTrackingEnabledInput {
  userBehaviorTrackingEnabled: Boolean!
}

input GlobalSettingsChangeTimeZoneInput {
  timeZone: String!
}

input GlobalSettingsChangeTimeZoneIpAddressWithPortInput {
  timeZoneIoAddressWithPort: String
}

input GlobalSettingsChangeUserBehaviorTrackingUrlInput {
  userBehaviorTrackingUrl: String
}

input IntOperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input MachineDepartmentOperationFilterInput {
  eq: MachineDepartment
  neq: MachineDepartment
  in: [MachineDepartment!]
  nin: [MachineDepartment!]
}

input MachineFamilyOperationFilterInput {
  eq: MachineFamily
  neq: MachineFamily
  in: [MachineFamily!]
  nin: [MachineFamily!]
}

input MachineFeaturesFilterInput {
  and: [MachineFeaturesFilterInput!]
  or: [MachineFeaturesFilterInput!]
  "Flag if machine has the AlarmHandling feature."
  hasAlarmHandlingFeature: BooleanOperationFilterInput
  "Version of the AlarmHandling feature if HasAlarmHandlingFeature is true, otherwise null."
  alarmHandlingFeatureVersion: IntOperationFilterInput
  "Flag if machine has the ProcessData feature."
  hasProcessDataFeature: BooleanOperationFilterInput
  "Version of the ProcessData feature if HasProcessDataFeature is true, otherwise null."
  processDataFeatureVersion: IntOperationFilterInput
  "Flag if machine has the ProductionPeriods feature."
  hasProductionPeriodsFeature: BooleanOperationFilterInput
  "Version of the ProductionPeriods feature if HasProductionPeriodsFeature is true, otherwise null."
  productionPeriodsFeatureVersion: IntOperationFilterInput
  "Flag if machine has the Material feature."
  hasMaterialFeature: BooleanOperationFilterInput
  "Version of the Material feature if HasMaterialFeature is true, otherwise null."
  materialFeatureVersion: IntOperationFilterInput
  "Flag if machine has the Messaging feature."
  hasMessagingFeature: BooleanOperationFilterInput
  "Version of the Messaging feature if HasMessagingFeature is true, otherwise null."
  messagingFeatureVersion: IntOperationFilterInput
  "Flag if machine has the Check feature."
  hasCheckFeature: BooleanOperationFilterInput
  "Version of the Check feature if HasCheckFeature is true, otherwise null."
  checkFeatureVersion: IntOperationFilterInput
  "Flag if machine has the DefectCheck feature."
  hasDefectCheckFeature: BooleanOperationFilterInput
  "Version of the DefectCheck feature if HasDefectCheckFeature is true, otherwise null."
  defectCheckFeatureVersion: IntOperationFilterInput
  "Flag if machine has the BarcodeCheck feature."
  hasBarcodeCheckFeature: BooleanOperationFilterInput
  "Version of the BarcodeCheck feature if HasBarcodeCheckFeature is true, otherwise null."
  barcodeCheckFeatureVersion: IntOperationFilterInput
  "Flag if machine has the PDFCheck feature."
  hasPdfCheckFeature: BooleanOperationFilterInput
  "Version of the PDFCheck feature if HasPdfCheckFeature is true, otherwise null."
  pdfCheckFeatureVersion: IntOperationFilterInput
  "Flag if machine has the PDFCheckPackageTransfer feature."
  hasPdfCheckPackageTransferFeature: BooleanOperationFilterInput
  "Version of the PDFCheckPackageTransfer feature if HasPdfCheckPackageTransferFeature is true, otherwise null."
  pdfCheckPackageTransferFeatureVersion: IntOperationFilterInput
  "Flag if machine has the BrowserOverlay feature."
  hasBrowserOverlayFeature: BooleanOperationFilterInput
  "Version of the BrowserOverlay feature if HasBrowserOverlayFeature is true, otherwise null."
  browserOverlayFeatureVersion: IntOperationFilterInput
  "Flag if machine has the Flow feature."
  hasFlowFeature: BooleanOperationFilterInput
  "Version of the Flow feature if HasFlowFeature is true, otherwise null."
  flowFeatureVersion: IntOperationFilterInput
  "Flag if machine has the RgbLabCheck feature."
  hasRgbLabCheckFeature: BooleanOperationFilterInput
  "Version of the RgbLabCheck feature if HasRgbLabCheckFeature is true, otherwise null."
  rgbLabCheckFeatureVersion: IntOperationFilterInput
}

input MachineFeaturesSortInput {
  "Flag if machine has the AlarmHandling feature."
  hasAlarmHandlingFeature: SortEnumType
  "Version of the AlarmHandling feature if HasAlarmHandlingFeature is true, otherwise null."
  alarmHandlingFeatureVersion: SortEnumType
  "Flag if machine has the ProcessData feature."
  hasProcessDataFeature: SortEnumType
  "Version of the ProcessData feature if HasProcessDataFeature is true, otherwise null."
  processDataFeatureVersion: SortEnumType
  "Flag if machine has the ProductionPeriods feature."
  hasProductionPeriodsFeature: SortEnumType
  "Version of the ProductionPeriods feature if HasProductionPeriodsFeature is true, otherwise null."
  productionPeriodsFeatureVersion: SortEnumType
  "Flag if machine has the Material feature."
  hasMaterialFeature: SortEnumType
  "Version of the Material feature if HasMaterialFeature is true, otherwise null."
  materialFeatureVersion: SortEnumType
  "Flag if machine has the Messaging feature."
  hasMessagingFeature: SortEnumType
  "Version of the Messaging feature if HasMessagingFeature is true, otherwise null."
  messagingFeatureVersion: SortEnumType
  "Flag if machine has the Check feature."
  hasCheckFeature: SortEnumType
  "Version of the Check feature if HasCheckFeature is true, otherwise null."
  checkFeatureVersion: SortEnumType
  "Flag if machine has the DefectCheck feature."
  hasDefectCheckFeature: SortEnumType
  "Version of the DefectCheck feature if HasDefectCheckFeature is true, otherwise null."
  defectCheckFeatureVersion: SortEnumType
  "Flag if machine has the BarcodeCheck feature."
  hasBarcodeCheckFeature: SortEnumType
  "Version of the BarcodeCheck feature if HasBarcodeCheckFeature is true, otherwise null."
  barcodeCheckFeatureVersion: SortEnumType
  "Flag if machine has the PDFCheck feature."
  hasPdfCheckFeature: SortEnumType
  "Version of the PDFCheck feature if HasPdfCheckFeature is true, otherwise null."
  pdfCheckFeatureVersion: SortEnumType
  "Flag if machine has the PDFCheckPackageTransfer feature."
  hasPdfCheckPackageTransferFeature: SortEnumType
  "Version of the PDFCheckPackageTransfer feature if HasPdfCheckPackageTransferFeature is true, otherwise null."
  pdfCheckPackageTransferFeatureVersion: SortEnumType
  "Flag if machine has the BrowserOverlay feature."
  hasBrowserOverlayFeature: SortEnumType
  "Version of the BrowserOverlay feature if HasBrowserOverlayFeature is true, otherwise null."
  browserOverlayFeatureVersion: SortEnumType
  "Flag if machine has the Flow feature."
  hasFlowFeature: SortEnumType
  "Version of the Flow feature if HasFlowFeature is true, otherwise null."
  flowFeatureVersion: SortEnumType
  "Flag if machine has the RgbLabCheck feature."
  hasRgbLabCheckFeature: SortEnumType
  "Version of the RgbLabCheck feature if HasRgbLabCheckFeature is true, otherwise null."
  rgbLabCheckFeatureVersion: SortEnumType
}

"Generic interface for machine entities of all machine families."
input MachineFilterInput {
  and: [MachineFilterInput!]
  or: [MachineFilterInput!]
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: StringOperationFilterInput
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: StringOperationFilterInput
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: MachineDepartmentOperationFilterInput
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: MachineFamilyOperationFilterInput
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: StringOperationFilterInput
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeaturesFilterInput
}

"Generic interface for machine entities of all machine families."
input MachineSortInput {
  "Unique identifier (usually WuH equipment number, like: \"EQ12345\") of the machine.\n[Source: Machine]"
  machineId: SortEnumType
  "Friendly name of the machine.\n[Source: Setting in Admin]"
  name: SortEnumType
  "The WuH department the machine is belonging to.\n[Source: Machine]"
  department: SortEnumType
  "Family \/ generic type of the machine.\n[Source: Machine]"
  machineFamily: SortEnumType
  "Detailed type of the machine.\n[Source: Machine]"
  machineType: SortEnumType
  "Features of the machine.\n[Source: Machine]"
  features: MachineFeaturesSortInput
}

input PhysicalAssetUpdateSettingsInput {
  updatePhysicalAssetSettingsRequest: UpdatePhysicalAssetSettingsRequestInput!
}

input PhysicalAssetsCreateAniloxCapabilityTestResultInput {
  createAniloxCapabilityTestResultRequest: CreateAniloxCapabilityTestResultRequestInput!
}

input PhysicalAssetsCreateAniloxInput {
  createAniloxPhysicalAssetRequest: CreateAniloxPhysicalAssetRequestInput!
}

input PhysicalAssetsCreateCleaningOperationInput {
  createCleaningOperationRequest: CreateCleaningOperationRequestInput!
}

input PhysicalAssetsCreateRefurbishingAniloxOperationInput {
  createRefurbishingAniloxOperationRequest: CreateRefurbishingAniloxOperationRequestInput!
}

input PhysicalAssetsCreateScrappingOperationInput {
  createScrappingOperationRequest: CreateScrappingOperationRequestInput!
}

input PhysicalAssetsCreateVolumeCapabilityTestResultInput {
  createVolumeCapabilityTestResultRequest: CreateVolumeCapabilityTestResultRequestInput!
}

input PhysicalAssetsUpdateAniloxInput {
  updateAniloxPhysicalAssetRequest: UpdateAniloxPhysicalAssetRequestInput!
}

input ProducedJobChangeMachineTargetDownTimeInMinInput {
  downTimeRequest: ProducedJobUpdateTargetDownTimeInMinRequestInput!
}

input ProducedJobChangeMachineTargetScrapCountDuringProductionInput {
  scrapCountDuringProductionRequest: ProducedJobUpdateTargetScrapCountDuringProductionRequestInput!
}

input ProducedJobChangeMachineTargetSetupTimeInMinInput {
  setupTimeRequest: ProducedJobUpdateTargetSetupTimeInMinRequestInput!
}

input ProducedJobChangeMachineTargetSpeedInput {
  targetSpeedRequest: ProducedJobUpdateTargetSpeedRequestInput!
}

"A request to change the target downtime for a job."
input ProducedJobUpdateTargetDownTimeInMinRequestInput {
  "Unique job identifier."
  associatedJob: String!
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  "Target downtime to set for the job."
  targetDownTimeInMin: Float!
}

"A request to change the target scrap count during production for a job."
input ProducedJobUpdateTargetScrapCountDuringProductionRequestInput {
  "Unique job identifier."
  associatedJob: String!
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  targetScrapCountDuringProduction: Float!
}

"A request to change the target setup time for a job."
input ProducedJobUpdateTargetSetupTimeInMinRequestInput {
  "Unique job identifier."
  associatedJob: String!
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  "Target setup time to set for the job."
  targetSetupTimeInMin: Float!
}

"A request to change the target speed for a job."
input ProducedJobUpdateTargetSpeedRequestInput {
  "Unique job identifier."
  associatedJob: String!
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  "Target speed to set for the job."
  targetSpeed: Float!
}

input ProductGroupChangeMachineNoteInput {
  productGroupChangeMachineNoteRequest: ProductGroupChangeMachineNoteRequestInput!
}

"A request to change the note for a machine."
input ProductGroupChangeMachineNoteRequestInput {
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  "Note of the product group for this machine id."
  note: String
  "ID of the product group (like: \"v0-T0-VX\")."
  paperSackProductGroupId: String!
}

input ProductGroupChangeMachineTargetSpeedInput {
  productGroupChangeMachineTargetSpeedRequest: ProductGroupChangeMachineTargetSpeedRequestInput!
}

"A request to change the target speed for a machine."
input ProductGroupChangeMachineTargetSpeedRequestInput {
  "Unique machine identifier (usually WuH equipment number, like: \"EQ12345\")."
  machineId: String!
  "ID of the product group (like: \"v0-T0-VX\")."
  paperSackProductGroupId: String!
  "Target speed to set for the machine id used by matching jobs."
  targetSpeed: Float
}

input ProductGroupChangeOverallNoteInput {
  productGroupChangeOverallNoteRequest: ProductGroupChangeOverallNoteRequestInput!
}

"A request the change the overall note for a product group."
input ProductGroupChangeOverallNoteRequestInput {
  "Note of the product group."
  note: String
  "ID of the product group (like: \"v0-T0-VX\")."
  paperSackProductGroupId: String!
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

"A request to update a physical asset of type anilox. Always send all properties, no partial updates are supported."
input UpdateAniloxPhysicalAssetRequestInput {
  "Date of the delivery of the physical asset."
  deliveredAt: DateTime
  "Description of the physical asset to create."
  description: String
  "Engraving of the physical asset to create."
  engraving: String
  "Initial time usage counter of the physical asset to create."
  initialTimeUsageCounter: Long
  "Initial usage counter of the physical asset to create."
  initialUsageCounter: Long
  "Inner diameter of the physical asset to create."
  innerDiameter: Float
  "Flag which signals if the physical asset to create is a sleeve."
  isSleeve: Boolean!
  "Manufacturer of the physical asset to create."
  manufacturer: String!
  "Outer diameter of the physical asset to create."
  outerDiameter: Float!
  "Id of the physical asset to update."
  physicalAssetId: String!
  "Preferred usage location of the physical asset to create."
  preferredUsageLocation: String
  "Print width of the physical asset to create."
  printWidth: Float!
  "List of unique scan codes (e.g. QR codes) identifying the physical asset."
  scanCodes: [String!]!
  "Screen of the physical asset to create."
  screen: Int!
  "Mandatory Serial number of the physical asset to create."
  serialNumber: String!
  "Set optical density of the physical asset to create."
  setOpticalDensityValue: Float
  "Set volume of the physical asset to create."
  setVolumeValue: Float!
}

"A request to update a physical asset settings."
input UpdatePhysicalAssetSettingsRequestInput {
  "The interval the physical asset should get cleaned."
  aniloxCleaningIntervalInMeter: Int!
}

input UserSettingsChangeExtrusionMachineFamilyInput {
  extrusionMachineFamily: MachineFamily
}

input UserSettingsChangeFavoriteDashboardExtrusionInput {
  dashboardId: String!
}

input UserSettingsChangeFavoriteDashboardOtherInput {
  dashboardId: String!
}

input UserSettingsChangeFavoriteDashboardPaperSackInput {
  dashboardId: String!
}

input UserSettingsChangeFavoriteDashboardPrintingInput {
  dashboardId: String!
}

input UserSettingsChangeLanguageInput {
  languageTag: String!
}

input UserSettingsChangeMachineDepartmentInput {
  machineDepartment: MachineDepartment
}

input UserSettingsChangeOtherMachineFamilyInput {
  otherMachineFamily: MachineFamily
}

input UserSettingsChangePaperSackMachineFamilyInput {
  paperSackMachineFamily: MachineFamily
}

input UserSettingsChangePrintingMachineFamilyInput {
  printingMachineFamily: MachineFamily
}

input UserSettingsChangeUnitSystemInput {
  unitRepresentation: UnitRepresentation!
}

enum AniloxCapabilityErrorType {
  SCORING_LINE
  SURFACE
  VOLUME
  OTHER
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
  VALIDATION
}

enum CapabilityTestType {
  VOLUME
  OPTICAL_DENSITY
  ANILOX
  VISUAL
}

enum CleaningOperationType {
  CHEMICAL_CLEANING
  ULTRASONIC_CLEANING
  LASER_CLEANING
}

enum EquipmentType {
  MACHINE
}

"Describes which of the different thickness measurement systems is used."
enum ExtrusionThicknessMeasurementType {
  "The standard measurement.\n(Blow film: bubble)"
  PRIMARY
  "The measurement after the MDO before winding station A."
  MDO_WINDER_A
  "The measurement after the MDO before winding station B."
  MDO_WINDER_B
}

"Machine departments supported by RUBY. A machine department does not necessary relate to a WuH business unit.\nIt's more related to the type of product."
enum MachineDepartment {
  "Film extrusion lines (blow and cast film)."
  EXTRUSION
  "Printing presses (flexo and gravure)."
  PRINTING
  "Paper sack machines (tuber and bottomers)."
  PAPER_SACK
  "All other machines."
  OTHER
}

"Machine family \/ Generic machine type."
enum MachineFamily {
  "Flexo printing press."
  FLEXO_PRINT
  "Gravure printing press."
  GRAVURE_PRINT
  "Blow film extrusion line."
  BLOW_FILM
  "Cast film extrusion line."
  CAST_FILM
  "Paper sack bottomer."
  PAPER_SACK_BOTTOMER
  "Paper sack tuber."
  PAPER_SACK_TUBER
  "All other machine families. Other machines can't be used as a machine filter. When it's used as filter, machines of all machine families will be selected."
  OTHER
}

enum OperationType {
  CLEANING
  REFURBISHING_ANILOX
  SCRAPPING
}

"Cut type of the paper sack tube, which has a high impact on the whole sack construction."
enum PaperSackCutType {
  "Flush-cut."
  FLUSH_CUT
  "Stepped-end cut."
  STEPPED_END
}

"Filter for paper sack machine families."
enum PaperSackMachineFamilyFilter {
  "Only paper sack bottomers."
  BOTTOMER
  "Only paper sack tubers."
  TUBER
  "Paper sack bottomers and paper sack tubers."
  BOTH
}

enum PhysicalAssetDefectType {
  LOW_VOLUME
  HIGH_VOLUME
  SCORING_LINE
  SURFACE_ANOMALY
  VOLUME_TRIGGERED_PRINT_ANOMALY
}

enum PhysicalAssetHistoryItemType {
  CREATED
  DELIVERED
  LOW_VOLUME
  HIGH_VOLUME
  CLEANED
  SCRAPPED
  SCORING_LINE
  SURFACE_ANOMALY
  VOLUME_TRIGGERED_PRINT_ANOMALY
  ANILOX_REFURBISHED
  VOLUME_MEASURED
}

enum PhysicalAssetType {
  ANILOX
  PLATE
}

enum PhysicalAssetsFilter {
  ALL
  UTILISABLE
  SCRAPPED
}

"Sort option for product groups."
enum ProductGroupSortOption {
  "No sorting."
  NONE
  "Sort by id ascending."
  ID_ASCENDING
  "Sort by id descending."
  ID_DESCENDING
  "Sort by friendly name ascending."
  FRIENDLY_NAME_ASCENDING
  "Sort by friendly name descending."
  FRIENDLY_NAME_DESCENDING
  "Sort by first production date ascending."
  FIRST_PRODUCTION_DATE_ASCENDING
  "Sort by first production date descending."
  FIRST_PRODUCTION_DATE_DESCENDING
  "Sort by last production date ascending."
  LAST_PRODUCTION_DATE_ASCENDING
  "Sort by last production date descending."
  LAST_PRODUCTION_DATE_DESCENDING
}

"Generic status category which a production status is assigned to.\nThis is the basis for calculation of key performance indicators like OEE (overall equipment effectiveness)."
enum ProductionStatusCategory {
  "Machine is running well."
  PRODUCTION
  "Machine is running but produces waste."
  SCRAP
  "Machine needs to be adjusted on job change-over (includes run-up)."
  SETUP
  "Unplanned machine stop."
  DOWN_TIME
  "Scheduled non-production \/ planned downtime."
  SCHEDULED_NON_PRODUCTION
  "Connection between machine and RUBY is interrupted."
  OFFLINE
  "Machine transmitted invalid data."
  INVALID_DATA
}

enum SortEnumType {
  ASC
  DESC
}

"Different sources for target speed values."
enum TargetValueSource {
  "Job-specific value defined\/corrected in RUBY (via OperatorUI or Track)"
  JOB_CORRECTION
  "Product(group)-specific setting (via Track)"
  PRODUCT_GROUP
  "Job-specific value defined in customer system (via Connect 4 Flow)"
  PRODUCTION_REQUEST
  "Value entered in ProControl (ProcessData)"
  MACHINE
  "Default setting (via Track section in Admin)"
  ADMIN_SETTING
}

"Enumeration of all supported history entry types."
enum TrackHistoryEntryType {
  "Changeover from one job to another (including run-up)."
  SETUP
  "Unplanned downtime of the machine."
  DOWNTIME
  "Machine is producing."
  PRODUCTION
  "Either scheduled non-production (lunch break, scheduled cleaning shift, weekend, holiday, ...)\nor this is shown in job history if the job got interrupted by another job."
  PRODUCTION_BREAK
  "Machine is only producing waste (this status does not exist on paper sack machines)."
  SCRAP
  "Machine is turned-off.\nIn error cases, this could also be a connection issue or the machine is sending invalid data."
  OFFLINE
}

"Unit representation systems supported by RUBY."
enum UnitRepresentation {
  "SI units (metric \/ international system of units)."
  SI
  "Non-SI units (imperial \/ US customary units)."
  NON_SI
}

directive @authorize("Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on OBJECT | FIELD_DEFINITION

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long
